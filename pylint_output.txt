************* Module .pylintrc
.pylintrc:1:0: R0022: Useless option value for '--disable', 'print-statement' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'parameter-unpacking' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'unpacking-in-except' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'old-raise-syntax' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'backtick' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'import-star-module-level' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'apply-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'basestring-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'buffer-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'cmp-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'coerce-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'execfile-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'file-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'long-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'raw_input-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'reduce-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'standarderror-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'unicode-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'xrange-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'coerce-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'delslice-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'getslice-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'setslice-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'no-absolute-import' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'old-division' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'dict-iter-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'dict-view-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'next-method-called' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'metaclass-assignment' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'indexing-exception' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'raising-string' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'reload-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'oct-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'hex-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'nonzero-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'cmp-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'input-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'round-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'intern-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'unichr-builtin' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'map-builtin-not-iterating' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'zip-builtin-not-iterating' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'range-builtin-not-iterating' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'filter-builtin-not-iterating' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'using-cmp-argument' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'div-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'idiv-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'rdiv-method' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'exception-message-attribute' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'invalid-str-codec' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'sys-max-int' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'bad-python3-import' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'deprecated-string-function' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'deprecated-str-translate-call' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'deprecated-itertools-function' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'deprecated-types-field' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'next-method-defined' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'dict-items-not-iterating' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'dict-keys-not-iterating' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'dict-values-not-iterating' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'deprecated-operator-function' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'deprecated-urllib-function' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'xreadlines-attribute' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'deprecated-sys-function' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'exception-escape' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: R0022: Useless option value for '--disable', 'comprehension-escape' was removed from pylint, see https://github.com/pylint-dev/pylint/pull/4942. (useless-option-value)
.pylintrc:1:0: W0012: Unknown option value for '--disable', expected a valid pylint message and got 'long-suffix' (unknown-option-value)
.pylintrc:1:0: W0012: Unknown option value for '--disable', expected a valid pylint message and got 'old-ne-operator' (unknown-option-value)
.pylintrc:1:0: W0012: Unknown option value for '--disable', expected a valid pylint message and got 'old-octal-literal' (unknown-option-value)
.pylintrc:1:0: W0012: Unknown option value for '--disable', expected a valid pylint message and got 'non-ascii-bytes-literal' (unknown-option-value)
.pylintrc:1:0: W0012: Unknown option value for '--disable', expected a valid pylint message and got 'eq-without-hash' (unknown-option-value)
************* Module spydrnet
spydrnet/__init__.py:70:0: C0301: Line too long (117/100) (line-too-long)
spydrnet/__init__.py:38:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/__init__.py:38:24: C0103: Argument name "LOG_LEVEL" doesn't conform to snake_case naming style (invalid-name)
spydrnet/__init__.py:38:24: W0621: Redefining name 'LOG_LEVEL' from outer scope (line 32) (redefined-outer-name)
spydrnet/__init__.py:55:0: E1205: Too many arguments for logging format string (logging-too-many-args)
spydrnet/__init__.py:58:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/__init__.py:68:12: W0621: Redefining name 'plugin' from outer scope (line 95) (redefined-outer-name)
spydrnet/__init__.py:68:22: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/__init__.py:68:22: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/__init__.py:76:16: W1201: Use lazy % formatting in logging functions (logging-not-lazy)
spydrnet/__init__.py:76:29: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/__init__.py:81:0: E1205: Too many arguments for logging format string (logging-too-many-args)
spydrnet/__init__.py:84:0: C0413: Import "from spydrnet import release" should be placed at the top of the module (wrong-import-position)
spydrnet/__init__.py:86:13: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/__init__.py:95:0: C0413: Import "from spydrnet.ir import *" should be placed at the top of the module (wrong-import-position)
spydrnet/__init__.py:96:0: C0413: Import "from spydrnet.util.hierarchical_reference import HRef" should be placed at the top of the module (wrong-import-position)
spydrnet/__init__.py:103:0: C0413: Import "from spydrnet.composers import compose" should be placed at the top of the module (wrong-import-position)
spydrnet/__init__.py:104:0: C0413: Import "from spydrnet.parsers import parse" should be placed at the top of the module (wrong-import-position)
spydrnet/__init__.py:105:0: C0413: Import "from spydrnet.plugins import namespace_manager" should be placed at the top of the module (wrong-import-position)
spydrnet/__init__.py:106:0: C0413: Import "from spydrnet.testing.test import run as test" should be placed at the top of the module (wrong-import-position)
spydrnet/__init__.py:107:0: C0413: Import "from spydrnet.util import get_cables, get_definitions, get_hcables, get_hinstances, get_hpins, get_hports, get_hwires, get_instances, get_libraries, get_netlists, get_pins, get_ports, get_wires" should be placed at the top of the module (wrong-import-position)
spydrnet/__init__.py:122:0: C0413: Import "from spydrnet.util.selection import ALL, BOTH, INSIDE, OUTSIDE" should be placed at the top of the module (wrong-import-position)
spydrnet/__init__.py:123:0: C0413: Import "from spydrnet.util.netlist_type import EDIF, VERILOG, EBLIF" should be placed at the top of the module (wrong-import-position)
spydrnet/__init__.py:126:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/__init__.py:127:4: W0621: Redefining name 'example_netlists_path' from outer scope (line 166) (redefined-outer-name)
spydrnet/__init__.py:148:12: W0621: Redefining name 'filename' from outer scope (line 95) (redefined-outer-name)
spydrnet/__init__.py:136:8: W0104: Statement seems to have no effect (pointless-statement)
spydrnet/__init__.py:149:23: W3101: Missing timeout argument for method 'requests.get' can cause your program to hang indefinitely (missing-timeout)
spydrnet/__init__.py:152:12: C0415: Import outside toplevel (zipfile) (import-outside-toplevel)
spydrnet/__init__.py:175:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/__init__.py:178:8: W0621: Redefining name 'filename' from outer scope (line 95) (redefined-outer-name)
spydrnet/__init__.py:201:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/__init__.py:201:33: W0621: Redefining name 'name' from outer scope (line 95) (redefined-outer-name)
spydrnet/__init__.py:202:4: W0621: Redefining name 'example_netlists_path' from outer scope (line 166) (redefined-outer-name)
************* Module spydrnet.release
spydrnet/release.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/release.py:15:0: W0622: Redefining built-in 'license' (redefined-builtin)
spydrnet/release.py:5:0: C0103: Constant name "name" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/release.py:6:0: C0103: Constant name "version" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/release.py:7:0: C0103: Constant name "release" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/release.py:8:0: C0103: Constant name "date" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/release.py:12:0: C0103: Constant name "dev" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/release.py:14:0: C0103: Constant name "description" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/release.py:15:0: C0103: Constant name "license" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/release.py:21:0: C0103: Constant name "maintainer" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/release.py:22:0: C0103: Constant name "maintainer_email" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/release.py:23:0: C0103: Constant name "url" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/release.py:69:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/release.py:70:4: W0603: Using the global statement (global-statement)
spydrnet/release.py:71:4: W0603: Using the global statement (global-statement)
spydrnet/release.py:72:4: W0603: Using the global statement (global-statement)
spydrnet/release.py:74:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/release.py:74:39: C0103: Variable name "fi" doesn't conform to snake_case naming style (invalid-name)
spydrnet/release.py:83:15: W0612: Unused variable 'char' (unused-variable)
spydrnet/release.py:94:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/release.py:95:4: C0415: Import outside toplevel (datetime) (import-outside-toplevel)
spydrnet/release.py:96:4: C0415: Import outside toplevel (time) (import-outside-toplevel)
spydrnet/release.py:97:4: C0415: Import outside toplevel (subprocess) (import-outside-toplevel)
spydrnet/release.py:99:4: W0603: Using the global statement (global-statement)
spydrnet/release.py:100:4: W0603: Using the global statement (global-statement)
spydrnet/release.py:127:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/release.py:127:44: C0103: Variable name "fh" doesn't conform to snake_case naming style (invalid-name)
spydrnet/release.py:119:25: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
************* Module spydrnet.uniquify
spydrnet/uniquify.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/uniquify.py:7:0: W0105: String statement has no effect (pointless-string-statement)
spydrnet/uniquify.py:19:4: W0603: Using the global statement (global-statement)
************* Module spydrnet.flatten
spydrnet/flatten.py:87:1: W0511: #TODO put this code somewhere where people can use it to visualize simple netlists (fixme)
spydrnet/flatten.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/flatten.py:4:0: W0401: Wildcard import spydrnet.ir (wildcard-import)
spydrnet/flatten.py:6:0: W0105: String statement has no effect (pointless-string-statement)
spydrnet/flatten.py:11:0: C0103: Constant name "unique_number" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/flatten.py:13:0: C0103: Constant name "mod_name_uid" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/flatten.py:17:4: W0603: Using the global statement (global-statement)
spydrnet/flatten.py:23:20: C0103: Argument name "e" doesn't conform to snake_case naming style (invalid-name)
spydrnet/flatten.py:24:4: W0603: Using the global statement (global-statement)
spydrnet/flatten.py:43:16: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/flatten.py:48:16: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/flatten.py:53:18: C0103: Argument name "e" doesn't conform to snake_case naming style (invalid-name)
spydrnet/flatten.py:56:8: W0602: Using global for 'mod_name_uid' but no assignment is done (global-variable-not-assigned)
spydrnet/flatten.py:70:8: C0103: Variable name "d" doesn't conform to snake_case naming style (invalid-name)
spydrnet/flatten.py:73:8: C0103: Variable name "d" doesn't conform to snake_case naming style (invalid-name)
spydrnet/flatten.py:4:0: W0614: Unused import(s) importlib, typing, RegisterModule, filename, eachModule, cls, name, plugin, ext_cls, cls_bases, get_active_plugins, Element, FirstClassElement, Bundle, Pin, InnerPin, OuterPin, Port, Wire, Instance, Definition, Library and Netlist from wildcard import of spydrnet.ir (unused-wildcard-import)
************* Module spydrnet.callback.callback_listener
spydrnet/callback/callback_listener.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/callback/callback_listener.py:17:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:20:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:23:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:26:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:29:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:32:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:35:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:38:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:41:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:44:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:47:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:50:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:53:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:56:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:59:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:62:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:65:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:68:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:71:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:74:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:77:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:80:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:83:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:86:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:89:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:92:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:95:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:98:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:98:4: R0912: Too many branches (27/12) (too-many-branches)
spydrnet/callback/callback_listener.py:98:4: R0915: Too many statements (55/50) (too-many-statements)
spydrnet/callback/callback_listener.py:216:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:219:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:222:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:225:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:228:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:231:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:234:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:237:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:240:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:243:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:246:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:249:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:252:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:255:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:258:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:261:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:264:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:269:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:272:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:275:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:278:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:281:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:284:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:287:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:290:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:293:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:296:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:299:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:299:4: R0912: Too many branches (27/12) (too-many-branches)
spydrnet/callback/callback_listener.py:299:4: R0915: Too many statements (55/50) (too-many-statements)
spydrnet/callback/callback_listener.py:417:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:420:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:423:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:426:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:429:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:432:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:435:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:438:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:441:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:444:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:447:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:450:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:453:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:456:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:459:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:462:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:465:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:470:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:473:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:476:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:479:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:482:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:485:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:488:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:491:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:494:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:497:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/callback/callback_listener.py:4:0: R0904: Too many public methods (83/20) (too-many-public-methods)
************* Module spydrnet.plugins
spydrnet/plugins/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module spydrnet.plugins.namespace_manager.edif_namespace
spydrnet/plugins/namespace_manager/edif_namespace.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/plugins/namespace_manager/edif_namespace.py:6:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/plugins/namespace_manager/edif_namespace.py:26:4: C0103: Method name "_check_EDIF_identifier" doesn't conform to snake_case naming style (invalid-name)
spydrnet/plugins/namespace_manager/edif_namespace.py:29:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/plugins/namespace_manager/edif_namespace.py:41:4: R0911: Too many return statements (11/6) (too-many-return-statements)
spydrnet/plugins/namespace_manager/edif_namespace.py:41:4: R0912: Too many branches (38/12) (too-many-branches)
spydrnet/plugins/namespace_manager/edif_namespace.py:41:4: R0915: Too many statements (58/50) (too-many-statements)
spydrnet/plugins/namespace_manager/edif_namespace.py:180:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
************* Module spydrnet.plugins.namespace_manager.default_namespace
spydrnet/plugins/namespace_manager/default_namespace.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/plugins/namespace_manager/default_namespace.py:4:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/plugins/namespace_manager/default_namespace.py:18:38: W0613: Unused argument 'element' (unused-argument)
spydrnet/plugins/namespace_manager/default_namespace.py:27:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/default_namespace.py:27:27: W0613: Unused argument 'key' (unused-argument)
spydrnet/plugins/namespace_manager/default_namespace.py:27:32: W0613: Unused argument 'value' (unused-argument)
spydrnet/plugins/namespace_manager/default_namespace.py:31:4: R0912: Too many branches (23/12) (too-many-branches)
spydrnet/plugins/namespace_manager/default_namespace.py:81:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/default_namespace.py:89:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/default_namespace.py:100:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/default_namespace.py:112:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/default_namespace.py:122:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/default_namespace.py:122:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
************* Module spydrnet.plugins.namespace_manager
spydrnet/plugins/namespace_manager/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/plugins/namespace_manager/__init__.py:17:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/plugins/namespace_manager/__init__.py:36:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/__init__.py:36:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
spydrnet/plugins/namespace_manager/__init__.py:100:24: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/plugins/namespace_manager/__init__.py:154:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/__init__.py:178:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/__init__.py:184:20: R1704: Redefining argument with the local name 'key' (redefined-argument-from-local)
spydrnet/plugins/namespace_manager/__init__.py:191:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/__init__.py:204:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/__init__.py:223:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/__init__.py:261:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/plugins/namespace_manager/__init__.py:17:0: R0904: Too many public methods (28/20) (too-many-public-methods)
************* Module spydrnet.util.get_hpins
spydrnet/util/get_hpins.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_hpins.py:103:0: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/util/get_hpins.py:111:0: R0914: Too many local variables (35/15) (too-many-locals)
spydrnet/util/get_hpins.py:116:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_hpins.py:116:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hpins.py:116:4: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
spydrnet/util/get_hpins.py:116:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hpins.py:222:16: C0206: Consider iterating with .items() (consider-using-dict-items)
spydrnet/util/get_hpins.py:211:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hpins.py:111:0: R0912: Too many branches (47/12) (too-many-branches)
spydrnet/util/get_hpins.py:111:0: R0915: Too many statements (94/50) (too-many-statements)
spydrnet/util/get_hpins.py:211:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hpins.py:231:0: R0914: Too many local variables (18/15) (too-many-locals)
spydrnet/util/get_hpins.py:257:40: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/get_hpins.py:234:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hpins.py:231:0: R0912: Too many branches (13/12) (too-many-branches)
spydrnet/util/get_hpins.py:234:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
************* Module spydrnet.util.get_hcables
spydrnet/util/get_hcables.py:159:0: C0325: Unnecessary parens after 'yield' keyword (superfluous-parens)
spydrnet/util/get_hcables.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_hcables.py:78:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/get_hcables.py:117:0: R0913: Too many arguments (7/5) (too-many-arguments)
spydrnet/util/get_hcables.py:129:0: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/util/get_hcables.py:129:0: R0914: Too many local variables (44/15) (too-many-locals)
spydrnet/util/get_hcables.py:135:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_hcables.py:135:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_hcables.py:135:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_hcables.py:135:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_hcables.py:135:4: R1702: Too many nested blocks (10/5) (too-many-nested-blocks)
spydrnet/util/get_hcables.py:135:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hcables.py:278:16: C0206: Consider iterating with .items() (consider-using-dict-items)
spydrnet/util/get_hcables.py:267:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hcables.py:129:0: R0912: Too many branches (59/12) (too-many-branches)
spydrnet/util/get_hcables.py:129:0: R0915: Too many statements (124/50) (too-many-statements)
spydrnet/util/get_hcables.py:267:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hcables.py:290:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hcables.py:290:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hcables.py:343:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
spydrnet/util/get_hcables.py:355:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
************* Module spydrnet.util.get_hports
spydrnet/util/get_hports.py:139:0: C0325: Unnecessary parens after 'yield' keyword (superfluous-parens)
spydrnet/util/get_hports.py:149:0: C0325: Unnecessary parens after 'yield' keyword (superfluous-parens)
spydrnet/util/get_hports.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_hports.py:103:0: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/util/get_hports.py:111:0: R0914: Too many local variables (33/15) (too-many-locals)
spydrnet/util/get_hports.py:116:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hports.py:116:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hports.py:116:4: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
spydrnet/util/get_hports.py:116:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hports.py:215:16: C0206: Consider iterating with .items() (consider-using-dict-items)
spydrnet/util/get_hports.py:204:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hports.py:111:0: R0912: Too many branches (45/12) (too-many-branches)
spydrnet/util/get_hports.py:111:0: R0915: Too many statements (91/50) (too-many-statements)
spydrnet/util/get_hports.py:204:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hports.py:227:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hports.py:227:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
************* Module spydrnet.util.get_libraries
spydrnet/util/get_libraries.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_libraries.py:96:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/get_libraries.py:139:0: R0913: Too many arguments (8/5) (too-many-arguments)
spydrnet/util/get_libraries.py:151:0: R0913: Too many arguments (7/5) (too-many-arguments)
spydrnet/util/get_libraries.py:151:0: R0914: Too many local variables (26/15) (too-many-locals)
spydrnet/util/get_libraries.py:156:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_libraries.py:156:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_libraries.py:156:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_libraries.py:156:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_libraries.py:151:0: R0912: Too many branches (60/12) (too-many-branches)
spydrnet/util/get_libraries.py:151:0: R0915: Too many statements (105/50) (too-many-statements)
************* Module spydrnet.util.hierarchical_reference
spydrnet/util/hierarchical_reference.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/hierarchical_reference.py:99:4: R0912: Too many branches (22/12) (too-many-branches)
spydrnet/util/hierarchical_reference.py:151:4: R0912: Too many branches (17/12) (too-many-branches)
spydrnet/util/hierarchical_reference.py:276:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/hierarchical_reference.py:324:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/util/hierarchical_reference.py:317:4: R0911: Too many return statements (18/6) (too-many-return-statements)
spydrnet/util/hierarchical_reference.py:317:4: R0912: Too many branches (24/12) (too-many-branches)
spydrnet/util/hierarchical_reference.py:403:45: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/hierarchical_reference.py:404:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
************* Module spydrnet.util.netlist_type
spydrnet/util/netlist_type.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/netlist_type.py:4:0: C0115: Missing class docstring (missing-class-docstring)
************* Module spydrnet.util.architecture
spydrnet/util/architecture.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module spydrnet.util.patterns
spydrnet/util/patterns.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/patterns.py:6:4: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/util/patterns.py:15:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
************* Module spydrnet.util.get_cables
spydrnet/util/get_cables.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_cables.py:91:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/get_cables.py:131:0: R0913: Too many arguments (8/5) (too-many-arguments)
spydrnet/util/get_cables.py:143:0: R0913: Too many arguments (7/5) (too-many-arguments)
spydrnet/util/get_cables.py:143:0: R0914: Too many local variables (31/15) (too-many-locals)
spydrnet/util/get_cables.py:149:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_cables.py:149:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_cables.py:149:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_cables.py:149:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_cables.py:283:16: C0206: Consider iterating with .items() (consider-using-dict-items)
spydrnet/util/get_cables.py:264:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_cables.py:143:0: R0912: Too many branches (73/12) (too-many-branches)
spydrnet/util/get_cables.py:143:0: R0915: Too many statements (128/50) (too-many-statements)
************* Module spydrnet.util.get_hwires
spydrnet/util/get_hwires.py:161:0: C0325: Unnecessary parens after 'yield' keyword (superfluous-parens)
spydrnet/util/get_hwires.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_hwires.py:78:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/get_hwires.py:117:0: R0913: Too many arguments (7/5) (too-many-arguments)
spydrnet/util/get_hwires.py:129:0: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/util/get_hwires.py:129:0: R0914: Too many local variables (45/15) (too-many-locals)
spydrnet/util/get_hwires.py:135:4: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
spydrnet/util/get_hwires.py:135:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_hwires.py:135:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_hwires.py:135:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_hwires.py:135:4: R1702: Too many nested blocks (10/5) (too-many-nested-blocks)
spydrnet/util/get_hwires.py:135:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hwires.py:284:16: C0206: Consider iterating with .items() (consider-using-dict-items)
spydrnet/util/get_hwires.py:273:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hwires.py:129:0: R0912: Too many branches (60/12) (too-many-branches)
spydrnet/util/get_hwires.py:129:0: R0915: Too many statements (125/50) (too-many-statements)
spydrnet/util/get_hwires.py:273:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hwires.py:293:0: R0914: Too many local variables (18/15) (too-many-locals)
spydrnet/util/get_hwires.py:319:40: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/get_hwires.py:296:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hwires.py:293:0: R0912: Too many branches (13/12) (too-many-branches)
spydrnet/util/get_hwires.py:296:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hwires.py:359:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
spydrnet/util/get_hwires.py:371:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
************* Module spydrnet.util.get_instances
spydrnet/util/get_instances.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_instances.py:97:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/get_instances.py:139:0: R0913: Too many arguments (8/5) (too-many-arguments)
spydrnet/util/get_instances.py:151:0: R0913: Too many arguments (7/5) (too-many-arguments)
spydrnet/util/get_instances.py:151:0: R0914: Too many local variables (27/15) (too-many-locals)
spydrnet/util/get_instances.py:156:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_instances.py:156:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_instances.py:156:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_instances.py:151:0: R0912: Too many branches (51/12) (too-many-branches)
spydrnet/util/get_instances.py:151:0: R0915: Too many statements (91/50) (too-many-statements)
************* Module spydrnet.util.selection
spydrnet/util/selection.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/selection.py:4:0: C0115: Missing class docstring (missing-class-docstring)
************* Module spydrnet.util
spydrnet/util/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module spydrnet.util.get_ports
spydrnet/util/get_ports.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_ports.py:96:0: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/util/get_ports.py:103:0: R0914: Too many local variables (21/15) (too-many-locals)
spydrnet/util/get_ports.py:106:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_ports.py:172:16: C0206: Consider iterating with .items() (consider-using-dict-items)
spydrnet/util/get_ports.py:152:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_ports.py:103:0: R0912: Too many branches (36/12) (too-many-branches)
spydrnet/util/get_ports.py:103:0: R0915: Too many statements (63/50) (too-many-statements)
************* Module spydrnet.util.get_wires
spydrnet/util/get_wires.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_wires.py:60:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/get_wires.py:89:0: R0914: Too many local variables (19/15) (too-many-locals)
spydrnet/util/get_wires.py:92:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_wires.py:92:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_wires.py:92:4: R1702: Too many nested blocks (11/5) (too-many-nested-blocks)
spydrnet/util/get_wires.py:157:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_wires.py:157:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
spydrnet/util/get_wires.py:157:4: R1702: Too many nested blocks (10/5) (too-many-nested-blocks)
spydrnet/util/get_wires.py:157:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_wires.py:89:0: R0912: Too many branches (68/12) (too-many-branches)
spydrnet/util/get_wires.py:89:0: R0915: Too many statements (114/50) (too-many-statements)
spydrnet/util/get_wires.py:157:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
************* Module spydrnet.util.get_hinstances
spydrnet/util/get_hinstances.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_hinstances.py:103:0: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/util/get_hinstances.py:111:0: R0914: Too many local variables (23/15) (too-many-locals)
spydrnet/util/get_hinstances.py:188:16: C0206: Consider iterating with .items() (consider-using-dict-items)
spydrnet/util/get_hinstances.py:177:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_hinstances.py:111:0: R0912: Too many branches (39/12) (too-many-branches)
spydrnet/util/get_hinstances.py:111:0: R0915: Too many statements (74/50) (too-many-statements)
spydrnet/util/get_hinstances.py:177:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_hinstances.py:201:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
************* Module spydrnet.util.get_definitions
spydrnet/util/get_definitions.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_definitions.py:95:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/get_definitions.py:137:0: R0913: Too many arguments (8/5) (too-many-arguments)
spydrnet/util/get_definitions.py:149:0: R0913: Too many arguments (7/5) (too-many-arguments)
spydrnet/util/get_definitions.py:149:0: R0914: Too many local variables (23/15) (too-many-locals)
spydrnet/util/get_definitions.py:154:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_definitions.py:154:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_definitions.py:154:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_definitions.py:154:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_definitions.py:154:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_definitions.py:251:16: C0206: Consider iterating with .items() (consider-using-dict-items)
spydrnet/util/get_definitions.py:232:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
spydrnet/util/get_definitions.py:149:0: R0912: Too many branches (56/12) (too-many-branches)
spydrnet/util/get_definitions.py:149:0: R0915: Too many statements (94/50) (too-many-statements)
************* Module spydrnet.util.get_netlists
spydrnet/util/get_netlists.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_netlists.py:95:0: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/util/get_netlists.py:102:0: R0914: Too many local variables (22/15) (too-many-locals)
spydrnet/util/get_netlists.py:102:0: R0912: Too many branches (31/12) (too-many-branches)
spydrnet/util/get_netlists.py:102:0: R0915: Too many statements (62/50) (too-many-statements)
************* Module spydrnet.util.get_pins
spydrnet/util/get_pins.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/util/get_pins.py:56:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/util/get_pins.py:86:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
spydrnet/util/get_pins.py:84:0: R0912: Too many branches (29/12) (too-many-branches)
spydrnet/util/get_pins.py:84:0: R0915: Too many statements (54/50) (too-many-statements)
************* Module spydrnet.global_state.global_callback
spydrnet/global_state/global_callback.py:274:5: W0511: TODO: look into inlining this function perhaps, may not be necessary since it won't be called (fixme)
spydrnet/global_state/global_callback.py:389:5: W0511: TODO: look into inlining this function perhaps, may not be necessary since it won't be called (fixme)
spydrnet/global_state/global_callback.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/global_state/global_callback.py:165:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:169:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:173:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:177:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:181:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:185:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:189:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:193:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:197:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:201:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:205:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:209:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:213:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:217:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:221:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:225:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:229:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:233:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:237:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:241:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:245:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:249:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:253:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:257:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:261:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:265:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:269:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:280:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:284:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:288:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:292:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:296:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:300:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:304:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:308:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:312:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:316:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:320:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:324:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:328:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:332:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:336:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:340:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:344:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:348:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:352:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:356:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:360:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:364:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:368:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:372:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:376:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:380:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_callback.py:384:0: C0116: Missing function or method docstring (missing-function-docstring)
************* Module spydrnet.global_state.global_service
spydrnet/global_state/global_service.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/global_state/global_service.py:4:0: C0103: Constant name "_registered_hierarchical_lookup" doesn't conform to UPPER_CASE naming style (invalid-name)
spydrnet/global_state/global_service.py:7:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_service.py:8:4: R1720: Unnecessary "else" after "raise", remove the "else" and de-indent the code inside it (no-else-raise)
spydrnet/global_state/global_service.py:16:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_service.py:21:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/global_state/global_service.py:22:4: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/global_state/global_service.py:21:0: R0911: Too many return statements (7/6) (too-many-return-statements)
spydrnet/global_state/global_service.py:21:0: R0912: Too many branches (19/12) (too-many-branches)
************* Module spydrnet.ir.netlist
spydrnet/ir/netlist.py:131:9: W0511: TODO: should We have a DRC that makes sure the instance is of a definition contained in (fixme)
spydrnet/ir/netlist.py:162:9: W0511: TODO: should We have a DRC that makes sure the instance is of a definition contained in (fixme)
spydrnet/ir/netlist.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/netlist.py:72:8: C0415: Import outside toplevel (spydrnet.composers.compose) (import-outside-toplevel)
spydrnet/ir/netlist.py:126:12: R1701: Consider merging these isinstance calls to isinstance(instance, (Definition, Instance)) (consider-merging-isinstance)
spydrnet/ir/netlist.py:130:8: W0212: Access to a protected member _call_netlist_top_instance of a client class (protected-access)
spydrnet/ir/netlist.py:157:12: R1701: Consider merging these isinstance calls to isinstance(instance, (Definition, Instance)) (consider-merging-isinstance)
spydrnet/ir/netlist.py:161:8: W0212: Access to a protected member _call_netlist_top_instance of a client class (protected-access)
spydrnet/ir/netlist.py:204:8: W0212: Access to a protected member _call_netlist_add_library of a client class (protected-access)
spydrnet/ir/netlist.py:209:8: W0212: Access to a protected member _netlist of a client class (protected-access)
spydrnet/ir/netlist.py:252:8: W0212: Access to a protected member _call_netlist_remove_library of a client class (protected-access)
spydrnet/ir/netlist.py:253:8: W0212: Access to a protected member _netlist of a client class (protected-access)
spydrnet/ir/netlist.py:258:25: W0212: Access to a protected member _definitions of a client class (protected-access)
spydrnet/ir/netlist.py:260:27: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/netlist.py:263:16: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/netlist.py:273:8: C0415: Import outside toplevel (spydrnet.ir.Netlist) (import-outside-toplevel)
spydrnet/ir/netlist.py:275:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/netlist.py:277:8: W0212: Access to a protected member _data of a client class (protected-access)
spydrnet/ir/netlist.py:281:33: W0212: Access to a protected member _clone of a client class (protected-access)
spydrnet/ir/netlist.py:282:8: W0212: Access to a protected member _libraries of a client class (protected-access)
spydrnet/ir/netlist.py:285:12: W0212: Access to a protected member _top_instance of a client class (protected-access)
spydrnet/ir/netlist.py:288:16: W0212: Access to a protected member _top_instance of a client class (protected-access)
spydrnet/ir/netlist.py:290:26: W0212: Access to a protected member _clone of a client class (protected-access)
spydrnet/ir/netlist.py:291:16: W0212: Access to a protected member _clone_rip_and_replace_in_definition of a client class (protected-access)
spydrnet/ir/netlist.py:292:16: W0212: Access to a protected member _clone_rip_and_replace_in_library of a client class (protected-access)
spydrnet/ir/netlist.py:293:16: W0212: Access to a protected member _top_instance of a client class (protected-access)
spydrnet/ir/netlist.py:295:23: W0212: Access to a protected member _libraries of a client class (protected-access)
spydrnet/ir/netlist.py:296:12: W0212: Access to a protected member _netlist of a client class (protected-access)
spydrnet/ir/netlist.py:297:12: W0212: Access to a protected member _clone_rip_and_replace of a client class (protected-access)
spydrnet/ir/netlist.py:307:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/netlist.py:308:8: W0212: Access to a protected member _clone_rip of a client class (protected-access)
spydrnet/ir/netlist.py:329:12: R1724: Unnecessary "else" after "continue", remove the "else" and de-indent the code inside it (no-else-continue)
************* Module spydrnet.ir.innerpin
spydrnet/ir/innerpin.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/innerpin.py:46:8: C0415: Import outside toplevel (spydrnet.ir.InnerPin) (import-outside-toplevel)
spydrnet/ir/innerpin.py:48:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/innerpin.py:50:8: W0212: Access to a protected member _wire of a client class (protected-access)
spydrnet/ir/innerpin.py:51:8: W0212: Access to a protected member _port of a client class (protected-access)
spydrnet/ir/innerpin.py:64:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/innerpin.py:65:8: W0212: Access to a protected member _clone_rip of a client class (protected-access)
************* Module spydrnet.ir.element
spydrnet/ir/element.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module spydrnet.ir.bundle
spydrnet/ir/bundle.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module spydrnet.ir.instance
spydrnet/ir/instance.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/instance.py:57:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/instance.py:76:8: W0212: Access to a protected member _call_instance_reference of a client class (protected-access)
spydrnet/ir/instance.py:83:20: W0212: Access to a protected member _instance of a client class (protected-access)
spydrnet/ir/instance.py:84:20: W0212: Access to a protected member _inner_pin of a client class (protected-access)
spydrnet/ir/instance.py:87:16: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/instance.py:95:16: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/instance.py:99:24: W0212: Access to a protected member _inner_pin of a client class (protected-access)
spydrnet/ir/instance.py:105:12: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/instance.py:113:8: C0415: Import outside toplevel (spydrnet.util.get_ports.get_ports) (import-outside-toplevel)
spydrnet/ir/instance.py:129:12: C0103: Variable name "op" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/instance.py:130:12: W0212: Access to a protected member _clone_rip_and_replace of a client class (protected-access)
spydrnet/ir/instance.py:139:12: C0103: Variable name "ip" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/instance.py:139:16: C0103: Variable name "op" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/instance.py:149:12: C0103: Variable name "op" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/instance.py:150:12: W0212: Access to a protected member _wire of a client class (protected-access)
spydrnet/ir/instance.py:151:8: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/instance.py:161:8: C0415: Import outside toplevel (spydrnet.ir.Instance) (import-outside-toplevel)
spydrnet/ir/instance.py:163:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/instance.py:165:8: W0212: Access to a protected member _parent of a client class (protected-access)
spydrnet/ir/instance.py:167:28: W0212: Access to a protected member _clone of a client class (protected-access)
spydrnet/ir/instance.py:168:12: W0212: Access to a protected member _instance of a client class (protected-access)
spydrnet/ir/instance.py:169:12: W0212: Access to a protected member _pins of a client class (protected-access)
spydrnet/ir/instance.py:170:8: W0212: Access to a protected member _reference of a client class (protected-access)
spydrnet/ir/instance.py:171:8: W0212: Access to a protected member _data of a client class (protected-access)
spydrnet/ir/instance.py:188:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/instance.py:189:8: W0212: Access to a protected member _clone_rip of a client class (protected-access)
spydrnet/ir/instance.py:198:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
spydrnet/ir/instance.py:200:17: W0212: Access to a protected member _children of a client class (protected-access)
spydrnet/ir/instance.py:200:55: W0212: Access to a protected member _cables of a client class (protected-access)
spydrnet/ir/instance.py:208:8: R1703: The if statement can be replaced with 'return bool(test)' (simplifiable-if-statement)
spydrnet/ir/instance.py:208:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/ir/instance.py:239:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module spydrnet.ir.outerpin
spydrnet/ir/outerpin.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/outerpin.py:22:8: C0415: Import outside toplevel (spydrnet.ir.OuterPin) (import-outside-toplevel)
spydrnet/ir/outerpin.py:87:8: C0415: Import outside toplevel (spydrnet.ir.OuterPin) (import-outside-toplevel)
spydrnet/ir/outerpin.py:89:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/outerpin.py:91:8: W0212: Access to a protected member _instance of a client class (protected-access)
spydrnet/ir/outerpin.py:92:8: W0212: Access to a protected member _inner_pin of a client class (protected-access)
spydrnet/ir/outerpin.py:93:8: W0212: Access to a protected member _wire of a client class (protected-access)
spydrnet/ir/outerpin.py:105:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/outerpin.py:106:8: W0212: Access to a protected member _clone_rip of a client class (protected-access)
spydrnet/ir/outerpin.py:109:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module spydrnet.ir.library
spydrnet/ir/library.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/library.py:113:8: W0212: Access to a protected member _call_library_add_definition of a client class (protected-access)
spydrnet/ir/library.py:118:8: W0212: Access to a protected member _library of a client class (protected-access)
spydrnet/ir/library.py:161:8: W0212: Access to a protected member _call_library_remove_definition of a client class (protected-access)
spydrnet/ir/library.py:162:8: W0212: Access to a protected member _library of a client class (protected-access)
spydrnet/ir/library.py:167:8: W0107: Unnecessary pass statement (unnecessary-pass)
spydrnet/ir/library.py:170:12: W0212: Access to a protected member _clone_rip_and_replace of a client class (protected-access)
spydrnet/ir/library.py:179:23: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/library.py:182:28: W0212: Access to a protected member _children of a client class (protected-access)
spydrnet/ir/library.py:183:16: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/library.py:183:16: W0212: Access to a protected member _reference of a client class (protected-access)
spydrnet/ir/library.py:185:12: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/library.py:196:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/library.py:198:8: W0212: Access to a protected member _netlist of a client class (protected-access)
spydrnet/ir/library.py:199:8: W0212: Access to a protected member _data of a client class (protected-access)
spydrnet/ir/library.py:203:35: W0212: Access to a protected member _clone of a client class (protected-access)
spydrnet/ir/library.py:204:8: W0212: Access to a protected member _definitions of a client class (protected-access)
spydrnet/ir/library.py:206:26: W0212: Access to a protected member _definitions of a client class (protected-access)
spydrnet/ir/library.py:207:12: W0212: Access to a protected member _library of a client class (protected-access)
spydrnet/ir/library.py:208:12: W0212: Access to a protected member _clone_rip_and_replace of a client class (protected-access)
spydrnet/ir/library.py:226:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/library.py:227:8: W0212: Access to a protected member _clone_rip of a client class (protected-access)
************* Module spydrnet.ir.cable
spydrnet/ir/cable.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/cable.py:19:4: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/ir/cable.py:120:8: W0212: Access to a protected member _call_cable_add_wire of a client class (protected-access)
spydrnet/ir/cable.py:125:8: W0212: Access to a protected member _cable of a client class (protected-access)
spydrnet/ir/cable.py:161:8: W0212: Access to a protected member _call_cable_remove_wire of a client class (protected-access)
spydrnet/ir/cable.py:162:8: W0212: Access to a protected member _cable of a client class (protected-access)
spydrnet/ir/cable.py:167:12: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/cable.py:168:12: W0212: Access to a protected member _clone_rip_and_replace of a client class (protected-access)
spydrnet/ir/cable.py:173:12: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/cable.py:174:12: W0212: Access to a protected member _clone_rip of a client class (protected-access)
spydrnet/ir/cable.py:175:12: W0212: Access to a protected member _cable of a client class (protected-access)
spydrnet/ir/cable.py:184:8: C0415: Import outside toplevel (spydrnet.ir.Cable) (import-outside-toplevel)
spydrnet/ir/cable.py:186:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/cable.py:189:12: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/cable.py:190:29: W0212: Access to a protected member _clone of a client class (protected-access)
spydrnet/ir/cable.py:191:8: W0212: Access to a protected member _wires of a client class (protected-access)
spydrnet/ir/cable.py:192:12: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/cable.py:192:17: W0212: Access to a protected member _wires of a client class (protected-access)
spydrnet/ir/cable.py:193:12: W0212: Access to a protected member _cable of a client class (protected-access)
spydrnet/ir/cable.py:194:8: W0212: Access to a protected member _definition of a client class (protected-access)
spydrnet/ir/cable.py:195:8: W0212: Access to a protected member _is_downto of a client class (protected-access)
spydrnet/ir/cable.py:196:8: W0212: Access to a protected member _is_scalar of a client class (protected-access)
spydrnet/ir/cable.py:197:8: W0212: Access to a protected member _lower_index of a client class (protected-access)
spydrnet/ir/cable.py:198:8: W0212: Access to a protected member _data of a client class (protected-access)
spydrnet/ir/cable.py:211:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/cable.py:212:8: W0212: Access to a protected member _clone_rip of a client class (protected-access)
************* Module spydrnet.ir.definition
spydrnet/ir/definition.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/definition.py:149:4: R0913: Too many arguments (8/5) (too-many-arguments)
spydrnet/ir/definition.py:195:8: W0212: Access to a protected member _call_definition_add_port of a client class (protected-access)
spydrnet/ir/definition.py:200:8: W0212: Access to a protected member _definition of a client class (protected-access)
spydrnet/ir/definition.py:203:16: W0212: Access to a protected member _pins of a client class (protected-access)
spydrnet/ir/definition.py:248:8: W0212: Access to a protected member _call_definition_remove_port of a client class (protected-access)
spydrnet/ir/definition.py:255:20: W0212: Access to a protected member _pins of a client class (protected-access)
spydrnet/ir/definition.py:256:16: W0212: Access to a protected member _instance of a client class (protected-access)
spydrnet/ir/definition.py:257:16: W0212: Access to a protected member _inner_pin of a client class (protected-access)
spydrnet/ir/definition.py:258:8: W0212: Access to a protected member _definition of a client class (protected-access)
spydrnet/ir/definition.py:312:8: W0212: Access to a protected member _call_definition_add_child of a client class (protected-access)
spydrnet/ir/definition.py:317:8: W0212: Access to a protected member _parent of a client class (protected-access)
spydrnet/ir/definition.py:362:8: W0212: Access to a protected member _call_definition_remove_child of a client class (protected-access)
spydrnet/ir/definition.py:363:8: W0212: Access to a protected member _parent of a client class (protected-access)
spydrnet/ir/definition.py:365:4: R0913: Too many arguments (7/5) (too-many-arguments)
spydrnet/ir/definition.py:410:8: W0212: Access to a protected member _call_definition_add_cable of a client class (protected-access)
spydrnet/ir/definition.py:415:8: W0212: Access to a protected member _definition of a client class (protected-access)
spydrnet/ir/definition.py:461:8: W0212: Access to a protected member _call_definition_remove_cable of a client class (protected-access)
spydrnet/ir/definition.py:462:8: W0212: Access to a protected member _definition of a client class (protected-access)
spydrnet/ir/definition.py:485:16: W0212: Access to a protected member _reference of a client class (protected-access)
spydrnet/ir/definition.py:486:16: W0212: Access to a protected member _clone_rip_and_replace_in_library of a client class (protected-access)
spydrnet/ir/definition.py:494:12: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/definition.py:494:12: W0212: Access to a protected member _reference of a client class (protected-access)
spydrnet/ir/definition.py:505:8: C0415: Import outside toplevel (spydrnet.ir.Definition) (import-outside-toplevel)
spydrnet/ir/definition.py:507:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/definition.py:509:8: W0212: Access to a protected member _data of a client class (protected-access)
spydrnet/ir/definition.py:510:8: W0212: Access to a protected member _library of a client class (protected-access)
spydrnet/ir/definition.py:513:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/definition.py:514:29: W0212: Access to a protected member _clone of a client class (protected-access)
spydrnet/ir/definition.py:515:8: W0212: Access to a protected member _ports of a client class (protected-access)
spydrnet/ir/definition.py:518:12: C0103: Variable name "ca" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/definition.py:519:30: W0212: Access to a protected member _clone of a client class (protected-access)
spydrnet/ir/definition.py:520:8: W0212: Access to a protected member _cables of a client class (protected-access)
spydrnet/ir/definition.py:523:12: C0103: Variable name "ch" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/definition.py:524:32: W0212: Access to a protected member _clone of a client class (protected-access)
spydrnet/ir/definition.py:525:8: W0212: Access to a protected member _children of a client class (protected-access)
spydrnet/ir/definition.py:527:8: W0212: Access to a protected member _references of a client class (protected-access)
spydrnet/ir/definition.py:529:20: W0212: Access to a protected member _ports of a client class (protected-access)
spydrnet/ir/definition.py:530:12: W0212: Access to a protected member _definition of a client class (protected-access)
spydrnet/ir/definition.py:531:12: W0212: Access to a protected member _clone_rip_and_replace of a client class (protected-access)
spydrnet/ir/definition.py:533:21: W0212: Access to a protected member _cables of a client class (protected-access)
spydrnet/ir/definition.py:534:12: W0212: Access to a protected member _definition of a client class (protected-access)
spydrnet/ir/definition.py:535:12: W0212: Access to a protected member _clone_rip_and_replace of a client class (protected-access)
spydrnet/ir/definition.py:537:24: W0212: Access to a protected member _children of a client class (protected-access)
spydrnet/ir/definition.py:538:12: W0212: Access to a protected member _parent of a client class (protected-access)
spydrnet/ir/definition.py:539:12: W0212: Access to a protected member _clone_rip_and_replace_in_definition of a client class (protected-access)
spydrnet/ir/definition.py:556:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/definition.py:557:8: W0212: Access to a protected member _clone_rip of a client class (protected-access)
************* Module spydrnet.ir.pin
spydrnet/ir/pin.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module spydrnet.ir.first_class_element
spydrnet/ir/first_class_element.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/first_class_element.py:96:8: W0212: Access to a protected member _call_dictionary_pop of a client class (protected-access)
************* Module spydrnet.ir
spydrnet/ir/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/__init__.py:44:40: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
************* Module spydrnet.ir.port
spydrnet/ir/port.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/port.py:35:4: R0913: Too many arguments (7/5) (too-many-arguments)
spydrnet/ir/port.py:122:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/ir/port.py:169:8: W0404: Reimport 'InnerPin' (imported line 4) (reimported)
spydrnet/ir/port.py:169:8: C0415: Import outside toplevel (spydrnet.ir.InnerPin) (import-outside-toplevel)
spydrnet/ir/port.py:175:16: W0212: Access to a protected member _pins of a client class (protected-access)
spydrnet/ir/port.py:191:8: W0212: Access to a protected member _call_port_add_pin of a client class (protected-access)
spydrnet/ir/port.py:196:8: W0212: Access to a protected member _port of a client class (protected-access)
spydrnet/ir/port.py:239:8: W0212: Access to a protected member _call_port_remove_pin of a client class (protected-access)
spydrnet/ir/port.py:246:20: W0212: Access to a protected member _pins of a client class (protected-access)
spydrnet/ir/port.py:247:16: W0212: Access to a protected member _instance of a client class (protected-access)
spydrnet/ir/port.py:248:16: W0212: Access to a protected member _inner_pin of a client class (protected-access)
spydrnet/ir/port.py:249:8: W0212: Access to a protected member _port of a client class (protected-access)
spydrnet/ir/port.py:254:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/port.py:255:12: W0212: Access to a protected member _clone_rip_and_replace of a client class (protected-access)
spydrnet/ir/port.py:261:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/port.py:262:12: W0212: Access to a protected member _clone_rip of a client class (protected-access)
spydrnet/ir/port.py:273:8: C0415: Import outside toplevel (spydrnet.ir.Port) (import-outside-toplevel)
spydrnet/ir/port.py:275:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/port.py:277:8: W0212: Access to a protected member _direction of a client class (protected-access)
spydrnet/ir/port.py:279:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/port.py:280:28: W0212: Access to a protected member _clone of a client class (protected-access)
spydrnet/ir/port.py:281:8: W0212: Access to a protected member _pins of a client class (protected-access)
spydrnet/ir/port.py:282:8: W0212: Access to a protected member _definition of a client class (protected-access)
spydrnet/ir/port.py:283:8: W0212: Access to a protected member _is_downto of a client class (protected-access)
spydrnet/ir/port.py:284:8: W0212: Access to a protected member _is_scalar of a client class (protected-access)
spydrnet/ir/port.py:285:8: W0212: Access to a protected member _lower_index of a client class (protected-access)
spydrnet/ir/port.py:286:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/port.py:286:17: W0212: Access to a protected member _pins of a client class (protected-access)
spydrnet/ir/port.py:287:12: W0212: Access to a protected member _port of a client class (protected-access)
spydrnet/ir/port.py:288:8: W0212: Access to a protected member _data of a client class (protected-access)
spydrnet/ir/port.py:302:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/port.py:303:8: W0212: Access to a protected member _clone_rip of a client class (protected-access)
************* Module spydrnet.ir.wire
spydrnet/ir/wire.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/wire.py:48:8: W0212: Access to a protected member _call_wire_connect_pin of a client class (protected-access)
spydrnet/ir/wire.py:59:12: W0212: Access to a protected member _wire of a client class (protected-access)
spydrnet/ir/wire.py:67:8: W0212: Access to a protected member _wire of a client class (protected-access)
spydrnet/ir/wire.py:136:8: W0212: Access to a protected member _call_wire_disconnect_pin of a client class (protected-access)
spydrnet/ir/wire.py:137:8: W0212: Access to a protected member _wire of a client class (protected-access)
spydrnet/ir/wire.py:143:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/wire.py:147:8: W0107: Unnecessary pass statement (unnecessary-pass)
spydrnet/ir/wire.py:154:8: W0107: Unnecessary pass statement (unnecessary-pass)
spydrnet/ir/wire.py:164:8: C0415: Import outside toplevel (spydrnet.ir.Wire) (import-outside-toplevel)
spydrnet/ir/wire.py:166:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/wire.py:168:8: W0212: Access to a protected member _cable of a client class (protected-access)
spydrnet/ir/wire.py:170:8: W0212: Access to a protected member _pins of a client class (protected-access)
spydrnet/ir/wire.py:181:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/wire.py:182:8: W0212: Access to a protected member _clone_rip of a client class (protected-access)
************* Module spydrnet.ir.views.outerpinsview
spydrnet/ir/views/outerpinsview.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/views/outerpinsview.py:5:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/ir/views/outerpinsview.py:6:4: W0246: Useless parent or super() delegation in method '__init__' (useless-parent-delegation)
************* Module spydrnet.ir.views.listview
spydrnet/ir/views/listview.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/views/listview.py:1:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/ir/views/listview.py:54:23: C0103: Argument name "n" doesn't conform to snake_case naming style (invalid-name)
spydrnet/ir/views/listview.py:75:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/listview.py:78:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/listview.py:78:20: W0622: Redefining built-in 'object' (redefined-builtin)
spydrnet/ir/views/listview.py:81:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module spydrnet.ir.views.setview
spydrnet/ir/views/setview.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/views/setview.py:1:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/ir/views/setview.py:73:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/setview.py:76:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/setview.py:79:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/setview.py:82:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/setview.py:85:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/setview.py:88:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/setview.py:91:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/setview.py:94:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module spydrnet.ir.views.dictview
spydrnet/ir/views/dictview.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/ir/views/dictview.py:1:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/ir/views/dictview.py:38:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/dictview.py:41:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/dictview.py:44:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/dictview.py:47:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/dictview.py:50:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/ir/views/dictview.py:53:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module spydrnet.compare.compare_netlists
spydrnet/compare/compare_netlists.py:133:0: C0301: Line too long (107/100) (line-too-long)
spydrnet/compare/compare_netlists.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/compare/compare_netlists.py:5:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/compare/compare_netlists.py:13:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:16:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:37:12: R1724: Unnecessary "else" after "continue", remove the "else" and de-indent the code inside it (no-else-continue)
spydrnet/compare/compare_netlists.py:46:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:69:12: R1724: Unnecessary "else" after "continue", remove the "else" and de-indent the code inside it (no-else-continue)
spydrnet/compare/compare_netlists.py:80:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:80:4: R0914: Too many local variables (20/15) (too-many-locals)
spydrnet/compare/compare_netlists.py:100:12: R1724: Unnecessary "else" after "continue", remove the "else" and de-indent the code inside it (no-else-continue)
spydrnet/compare/compare_netlists.py:121:12: R1724: Unnecessary "else" after "continue", remove the "else" and de-indent the code inside it (no-else-continue)
spydrnet/compare/compare_netlists.py:136:12: R1724: Unnecessary "else" after "continue", remove the "else" and de-indent the code inside it (no-else-continue)
spydrnet/compare/compare_netlists.py:141:16: R1724: Unnecessary "else" after "continue", remove the "else" and de-indent the code inside it (no-else-continue)
spydrnet/compare/compare_netlists.py:159:8: C0103: Variable name "ci" doesn't conform to snake_case naming style (invalid-name)
spydrnet/compare/compare_netlists.py:166:12: C0103: Variable name "ci" doesn't conform to snake_case naming style (invalid-name)
spydrnet/compare/compare_netlists.py:168:8: C0103: Variable name "oi" doesn't conform to snake_case naming style (invalid-name)
spydrnet/compare/compare_netlists.py:175:12: C0103: Variable name "oi" doesn't conform to snake_case naming style (invalid-name)
spydrnet/compare/compare_netlists.py:177:8: C0206: Consider iterating with .items() (consider-using-dict-items)
spydrnet/compare/compare_netlists.py:177:17: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
spydrnet/compare/compare_netlists.py:80:4: R0912: Too many branches (18/12) (too-many-branches)
spydrnet/compare/compare_netlists.py:182:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:208:23: C0123: Use isinstance() rather than type() for a typecheck. (unidiomatic-typecheck)
spydrnet/compare/compare_netlists.py:216:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:233:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:238:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:274:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:287:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:325:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:329:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/compare/compare_netlists.py:344:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/compare/compare_netlists.py:366:12: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
spydrnet/compare/compare_netlists.py:366:16: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
spydrnet/compare/compare_netlists.py:367:25: W0612: Unused variable 'value' (unused-variable)
spydrnet/compare/compare_netlists.py:373:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:381:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/compare/compare_netlists.py:381:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
************* Module spydrnet.composers
spydrnet/composers/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/composers/__init__.py:7:0: W0102: Dangerous default value [] as argument (dangerous-default-value)
spydrnet/composers/__init__.py:7:0: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/composers/__init__.py:21:12: W0719: Raising too general exception: Exception (broad-exception-raised)
spydrnet/composers/__init__.py:30:27: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
************* Module spydrnet.composers.verilog.composer
spydrnet/composers/verilog/composer.py:699:9: W0511: TODO maybe also check if all of the cable is used. So no skipped wires. (fixme)
spydrnet/composers/verilog/composer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/composers/verilog/composer.py:8:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/composers/verilog/composer.py:8:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
spydrnet/composers/verilog/composer.py:36:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/verilog/composer.py:36:18: C0103: Argument name "ir" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:41:8: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:41:12: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/composers/verilog/composer.py:41:12: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/composers/verilog/composer.py:70:16: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:90:16: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:111:8: W0107: Unnecessary pass statement (unnecessary-pass)
spydrnet/composers/verilog/composer.py:113:38: C0103: Argument name "o" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:123:19: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:185:12: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:213:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:222:12: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:238:12: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:264:12: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:297:16: W0104: Statement seems to have no effect (pointless-statement)
spydrnet/composers/verilog/composer.py:312:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:323:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/verilog/composer.py:323:28: C0103: Argument name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:348:12: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:357:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:374:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:376:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:394:8: C0103: Variable name "hi" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:395:8: C0103: Variable name "li" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:400:8: C0103: Variable name "hi" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:401:8: C0103: Variable name "li" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:370:8: W0612: Unused variable 'left_wires' (unused-variable)
spydrnet/composers/verilog/composer.py:371:8: W0612: Unused variable 'right_wires' (unused-variable)
spydrnet/composers/verilog/composer.py:412:15: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:436:15: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:461:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:485:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:502:16: C0103: Variable name "wl" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:503:16: C0103: Variable name "wr" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:506:20: C0103: Variable name "wl" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:507:16: C0103: Variable name "il" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:508:16: C0103: Variable name "ir" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:513:4: R0914: Too many local variables (16/15) (too-many-locals)
spydrnet/composers/verilog/composer.py:519:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:532:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:539:16: C0103: Variable name "wl" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:540:16: C0103: Variable name "wr" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:543:20: C0103: Variable name "wl" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:544:16: C0103: Variable name "il" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:545:16: C0103: Variable name "ir" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:550:26: C0103: Argument name "o" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:599:27: E1120: No value for argument 'o' in method call (no-value-for-parameter)
spydrnet/composers/verilog/composer.py:611:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
spydrnet/composers/verilog/composer.py:634:19: R1716: Simplify chained comparison between the operands (chained-comparison)
spydrnet/composers/verilog/composer.py:650:16: R1716: Simplify chained comparison between the operands (chained-comparison)
spydrnet/composers/verilog/composer.py:655:16: R1716: Simplify chained comparison between the operands (chained-comparison)
spydrnet/composers/verilog/composer.py:667:12: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:677:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:715:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/verilog/composer.py:721:37: C0103: Argument name "o" doesn't conform to snake_case naming style (invalid-name)
************* Module spydrnet.composers.edif.edifify_names
spydrnet/composers/edif/edifify_names.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/composers/edif/edifify_names.py:78:12: C0103: Variable name "r" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/edif/edifify_names.py:79:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/composers/edif/edifify_names.py:96:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
spydrnet/composers/edif/edifify_names.py:134:12: C0103: Variable name "r" doesn't conform to snake_case naming style (invalid-name)
************* Module spydrnet.composers.edif.composer
spydrnet/composers/edif/composer.py:352:13: W0511: TODO Clean up code in this if statement (fixme)
spydrnet/composers/edif/composer.py:398:9: W0511: TODO this should be checked against some sort of metadata (fixme)
spydrnet/composers/edif/composer.py:427:13: W0511: for port in cable.getConnectionList(): #TODO create fuction cable.getConnectionList() (fixme)
spydrnet/composers/edif/composer.py:533:9: W0511: TODO this only handles string properties for now (fixme)
spydrnet/composers/edif/composer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/composers/edif/composer.py:4:0: W0401: Wildcard import spydrnet.ir (wildcard-import)
spydrnet/composers/edif/composer.py:18:18: C0103: Argument name "ir" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/edif/composer.py:60:24: W0719: Raising too general exception: Exception (broad-exception-raised)
spydrnet/composers/edif/composer.py:80:12: W0719: Raising too general exception: Exception (broad-exception-raised)
spydrnet/composers/edif/composer.py:101:20: C0103: Argument name "o" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/edif/composer.py:127:12: C0103: Variable name "o" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/edif/composer.py:136:8: W0621: Redefining name 'name' from outer scope (line 4) (redefined-outer-name)
spydrnet/composers/edif/composer.py:135:12: W0719: Raising too general exception: Exception (broad-exception-raised)
spydrnet/composers/edif/composer.py:146:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/composers/edif/composer.py:146:36: C0103: Variable name "fi" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/edif/composer.py:150:24: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/composers/edif/composer.py:150:24: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/composers/edif/composer.py:188:12: W0719: Raising too general exception: Exception (broad-exception-raised)
spydrnet/composers/edif/composer.py:186:8: W0612: Unused variable 'test' (unused-variable)
spydrnet/composers/edif/composer.py:220:28: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/composers/edif/composer.py:227:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/composers/edif/composer.py:233:20: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/composers/edif/composer.py:284:16: W0621: Redefining name 'name' from outer scope (line 4) (redefined-outer-name)
spydrnet/composers/edif/composer.py:298:12: W0621: Redefining name 'name' from outer scope (line 4) (redefined-outer-name)
spydrnet/composers/edif/composer.py:380:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
spydrnet/composers/edif/composer.py:449:12: W0621: Redefining name 'name' from outer scope (line 4) (redefined-outer-name)
spydrnet/composers/edif/composer.py:457:12: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/edif/composer.py:472:12: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
spydrnet/composers/edif/composer.py:472:16: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/edif/composer.py:485:8: W0107: Unnecessary pass statement (unnecessary-pass)
spydrnet/composers/edif/composer.py:491:12: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
spydrnet/composers/edif/composer.py:491:16: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/edif/composer.py:487:42: W0613: Unused argument 'cable_name' (unused-argument)
spydrnet/composers/edif/composer.py:512:30: C0103: Argument name "netlistObj" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/edif/composer.py:513:8: W0621: Redefining name 'name' from outer scope (line 4) (redefined-outer-name)
spydrnet/composers/edif/composer.py:514:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/composers/edif/composer.py:517:12: C0103: Variable name "oldName" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/edif/composer.py:28:8: W0201: Attribute 'output_filename' defined outside __init__ (attribute-defined-outside-init)
spydrnet/composers/edif/composer.py:32:12: W0201: Attribute 'filename' defined outside __init__ (attribute-defined-outside-init)
spydrnet/composers/edif/composer.py:8:0: R0903: Too few public methods (1/2) (too-few-public-methods)
spydrnet/composers/edif/composer.py:2:0: W0611: Unused import inspect (unused-import)
spydrnet/composers/edif/composer.py:4:0: W0614: Unused import(s) importlib, typing, RegisterModule, filename, eachModule, cls, name, plugin, ext_cls, cls_bases, get_active_plugins, Element, FirstClassElement, Bundle, Pin, InnerPin, Wire, Cable, Instance, Definition, Library and Netlist from wildcard import of spydrnet.ir (unused-wildcard-import)
************* Module spydrnet.composers.eblif.eblif_composer
spydrnet/composers/eblif/eblif_composer.py:181:0: C0325: Unnecessary parens after 'if' keyword (superfluous-parens)
spydrnet/composers/eblif/eblif_composer.py:194:0: C0325: Unnecessary parens after 'if' keyword (superfluous-parens)
spydrnet/composers/eblif/eblif_composer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/composers/eblif/eblif_composer.py:6:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/composers/eblif/eblif_composer.py:16:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:16:18: C0103: Argument name "ir" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/eblif/eblif_composer.py:20:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:22:12: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/eblif/eblif_composer.py:22:16: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/composers/eblif/eblif_composer.py:24:12: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/eblif/eblif_composer.py:24:16: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/composers/eblif/eblif_composer.py:24:16: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/composers/eblif/eblif_composer.py:27:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:30:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:33:23: C0103: Argument name "ir" doesn't conform to snake_case naming style (invalid-name)
spydrnet/composers/eblif/eblif_composer.py:39:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:47:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:57:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:68:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:93:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:100:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:102:29: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
spydrnet/composers/eblif/eblif_composer.py:104:27: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
spydrnet/composers/eblif/eblif_composer.py:106:28: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
spydrnet/composers/eblif/eblif_composer.py:108:28: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
spydrnet/composers/eblif/eblif_composer.py:110:28: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
spydrnet/composers/eblif/eblif_composer.py:113:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:121:12: W0622: Redefining built-in 'type' (redefined-builtin)
spydrnet/composers/eblif/eblif_composer.py:129:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:146:57: W0640: Cell variable port defined in loop (cell-var-from-loop)
spydrnet/composers/eblif/eblif_composer.py:129:4: R0912: Too many branches (13/12) (too-many-branches)
spydrnet/composers/eblif/eblif_composer.py:165:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:203:16: W0104: Statement seems to have no effect (pointless-statement)
spydrnet/composers/eblif/eblif_composer.py:207:16: W0104: Statement seems to have no effect (pointless-statement)
spydrnet/composers/eblif/eblif_composer.py:211:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:223:62: W0640: Cell variable port_type defined in loop (cell-var-from-loop)
spydrnet/composers/eblif/eblif_composer.py:236:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:244:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:256:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/composers/eblif/eblif_composer.py:278:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module spydrnet.testing.test
spydrnet/testing/test.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/testing/test.py:13:4: C0415: Import outside toplevel (pytest) (import-outside-toplevel)
************* Module spydrnet.testing
spydrnet/testing/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module spydrnet.shortcuts.getter
spydrnet/shortcuts/getter.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/shortcuts/getter.py:1:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/shortcuts/getter.py:9:8: C0415: Import outside toplevel (spydrnet.util.get_netlists) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:18:8: C0415: Import outside toplevel (spydrnet.util.get_libraries) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:27:8: C0415: Import outside toplevel (spydrnet.util.get_definitions) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:36:8: C0415: Import outside toplevel (spydrnet.util.get_instances) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:45:8: C0415: Import outside toplevel (spydrnet.util.get_ports) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:54:8: C0415: Import outside toplevel (spydrnet.util.get_pins) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:63:8: C0415: Import outside toplevel (spydrnet.util.get_cables) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:72:8: C0415: Import outside toplevel (spydrnet.util.get_wires) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:81:8: C0415: Import outside toplevel (spydrnet.util.get_hinstances) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:90:8: C0415: Import outside toplevel (spydrnet.util.get_hports) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:99:8: C0415: Import outside toplevel (spydrnet.util.get_hpins) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:108:8: C0415: Import outside toplevel (spydrnet.util.get_hcables) (import-outside-toplevel)
spydrnet/shortcuts/getter.py:117:8: C0415: Import outside toplevel (spydrnet.util.get_hwires) (import-outside-toplevel)
************* Module spydrnet.parsers.primitive_library_reader
spydrnet/parsers/primitive_library_reader.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/primitive_library_reader.py:32:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/primitive_library_reader.py:45:14: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/parsers/primitive_library_reader.py:47:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/primitive_library_reader.py:53:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/primitive_library_reader.py:55:14: R1714: Consider merging these comparisons with 'in' by using 'token not in (vt.MODULE, vt.PRIMITIVE)'. Use a set instead if elements are hashable. (consider-using-in)
spydrnet/parsers/primitive_library_reader.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/primitive_library_reader.py:65:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/primitive_library_reader.py:68:27: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
spydrnet/parsers/primitive_library_reader.py:74:56: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
spydrnet/parsers/primitive_library_reader.py:80:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module spydrnet.parsers
spydrnet/parsers/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/__init__.py:5:0: W0105: String statement has no effect (pointless-string-statement)
spydrnet/parsers/__init__.py:50:46: W0622: Redefining built-in 'zip' (redefined-builtin)
spydrnet/parsers/__init__.py:46:11: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/parsers/__init__.py:67:8: C0415: Import outside toplevel (spydrnet.parsers.edif.parser.EdifParser) (import-outside-toplevel)
spydrnet/parsers/__init__.py:70:8: C0415: Import outside toplevel (spydrnet.parsers.verilog.parser.VerilogParser) (import-outside-toplevel)
spydrnet/parsers/__init__.py:74:8: C0415: Import outside toplevel (spydrnet.parsers.eblif.eblif_parser.EBLIFParser) (import-outside-toplevel)
spydrnet/parsers/__init__.py:78:27: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/parsers/__init__.py:88:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/__init__.py:94:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/__init__.py:95:4: C0415: Import outside toplevel (spydrnet.parsers.primitive_library_reader.PrimitiveLibraryReader) (import-outside-toplevel)
spydrnet/parsers/__init__.py:101:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/__init__.py:102:4: C0415: Import outside toplevel (spydrnet.parsers.eblif.eblif_parser.EBLIFParser) (import-outside-toplevel)
************* Module spydrnet.parsers.primatives.parse_primatives
spydrnet/parsers/primatives/parse_primatives.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/primatives/parse_primatives.py:55:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/parsers/primatives/parse_primatives.py:55:35: C0103: Variable name "vf" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/primatives/parse_primatives.py:69:12: R1724: Unnecessary "elif" after "continue", remove the leading "el" from "elif" (no-else-continue)
spydrnet/parsers/primatives/parse_primatives.py:110:4: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/parsers/primatives/parse_primatives.py:111:21: E1101: Module 'spydrnet' has no 'create_definition' member (no-member)
spydrnet/parsers/primatives/parse_primatives.py:114:12: C0103: Variable name "o" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/primatives/parse_primatives.py:116:12: C0103: Variable name "io" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/primatives/parse_primatives.py:110:40: W0613: Unused argument 'name' (unused-argument)
spydrnet/parsers/primatives/parse_primatives.py:110:46: W0613: Unused argument 'parameters' (unused-argument)
spydrnet/parsers/primatives/parse_primatives.py:121:15: E1101: Module 'spydrnet' has no 'create_port' member (no-member)
spydrnet/parsers/primatives/parse_primatives.py:20:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module spydrnet.parsers.verilog.verilog_tokens
spydrnet/parsers/verilog/verilog_tokens.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/verilog/verilog_tokens.py:205:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/verilog_tokens.py:206:4: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
spydrnet/parsers/verilog/verilog_tokens.py:216:12: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/verilog_tokens.py:222:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/verilog_tokens.py:225:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/verilog_tokens.py:231:0: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/verilog_tokens.py:232:4: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
************* Module spydrnet.parsers.verilog.parser
spydrnet/parsers/verilog/parser.py:567:0: C0301: Line too long (102/100) (line-too-long)
spydrnet/parsers/verilog/parser.py:766:0: C0301: Line too long (101/100) (line-too-long)
spydrnet/parsers/verilog/parser.py:1043:0: C0301: Line too long (108/100) (line-too-long)
spydrnet/parsers/verilog/parser.py:1043:0: C0325: Unnecessary parens after 'if' keyword (superfluous-parens)
spydrnet/parsers/verilog/parser.py:1423:0: C0301: Line too long (110/100) (line-too-long)
spydrnet/parsers/verilog/parser.py:1527:0: C0301: Line too long (110/100) (line-too-long)
spydrnet/parsers/verilog/parser.py:1:0: C0302: Too many lines in module (1610/1000) (too-many-lines)
spydrnet/parsers/verilog/parser.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/verilog/parser.py:12:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
spydrnet/parsers/verilog/parser.py:53:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/verilog/parser.py:68:16: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:77:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:83:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:116:8: C2801: Unnecessarily calls dunder method __del__. Use del keyword. (unnecessary-dunder-call)
spydrnet/parsers/verilog/parser.py:119:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:122:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:139:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:181:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:239:23: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:246:16: W0107: Unnecessary pass statement (unnecessary-pass)
spydrnet/parsers/verilog/parser.py:181:4: R0912: Too many branches (18/12) (too-many-branches)
spydrnet/parsers/verilog/parser.py:259:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:261:12: C0103: Variable name "d" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:265:4: W0102: Dangerous default value [] as argument (dangerous-default-value)
spydrnet/parsers/verilog/parser.py:275:15: R1714: Consider merging these comparisons with 'in' by using 'token in (vt.MODULE, vt.PRIMITIVE)'. Use a set instead if elements are hashable. (consider-using-in)
spydrnet/parsers/verilog/parser.py:307:14: R1714: Consider merging these comparisons with 'in' by using 'token not in (vt.END_MODULE, vt.END_PRIMITIVE)'. Use a set instead if elements are hashable. (consider-using-in)
spydrnet/parsers/verilog/parser.py:320:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:505:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
spydrnet/parsers/verilog/parser.py:525:16: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:535:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:535:29: C0103: Argument name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:572:16: R1712: Consider using tuple unpacking for swapping variables (consider-swap-variables)
spydrnet/parsers/verilog/parser.py:589:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
spydrnet/parsers/verilog/parser.py:624:23: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:699:20: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:714:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:748:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:868:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:884:19: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:899:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:918:8: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:927:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:993:12: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
spydrnet/parsers/verilog/parser.py:1008:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1008:28: C0103: Argument name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:1013:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1013:4: R0914: Too many local variables (16/15) (too-many-locals)
spydrnet/parsers/verilog/parser.py:1069:16: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
spydrnet/parsers/verilog/parser.py:1079:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1148:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/verilog/parser.py:1165:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1188:22: R1714: Consider merging these comparisons with 'in' by using 'token not in (vt.STAR, vt.COMMA)'. Use a set instead if elements are hashable. (consider-using-in)
spydrnet/parsers/verilog/parser.py:1251:4: R0913: Too many arguments (7/5) (too-many-arguments)
spydrnet/parsers/verilog/parser.py:1251:4: R0914: Too many local variables (16/15) (too-many-locals)
spydrnet/parsers/verilog/parser.py:1275:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1278:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:1282:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1283:15: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:1287:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1288:15: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:1291:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1291:43: C0103: Argument name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:1301:12: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:1302:16: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:1307:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1316:16: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:1329:16: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:1334:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1339:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/verilog/parser.py:1348:4: W0105: String statement has no effect (pointless-string-statement)
spydrnet/parsers/verilog/parser.py:1385:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
spydrnet/parsers/verilog/parser.py:1394:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1394:4: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/parsers/verilog/parser.py:1441:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1441:4: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/parsers/verilog/parser.py:1464:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1470:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1487:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1487:4: R0913: Too many arguments (7/5) (too-many-arguments)
spydrnet/parsers/verilog/parser.py:1536:16: W0104: Statement seems to have no effect (pointless-statement)
spydrnet/parsers/verilog/parser.py:1487:4: R0912: Too many branches (13/12) (too-many-branches)
spydrnet/parsers/verilog/parser.py:1550:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1550:4: R0913: Too many arguments (6/5) (too-many-arguments)
spydrnet/parsers/verilog/parser.py:1573:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1579:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1582:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1584:12: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:1593:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/parser.py:1594:12: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/parser.py:12:0: R0904: Too many public methods (59/20) (too-many-public-methods)
************* Module spydrnet.parsers.verilog.tokenizer
spydrnet/parsers/verilog/tokenizer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/verilog/tokenizer.py:13:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/parsers/verilog/tokenizer.py:15:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:20:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:26:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:37:16: W0622: Redefining built-in 'zip' (redefined-builtin)
spydrnet/parsers/verilog/tokenizer.py:44:36: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/parsers/verilog/tokenizer.py:54:36: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/parsers/verilog/tokenizer.py:47:22: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/parsers/verilog/tokenizer.py:50:25: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/parsers/verilog/tokenizer.py:54:36: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/parsers/verilog/tokenizer.py:67:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:74:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:82:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:83:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/verilog/tokenizer.py:100:12: C0103: Variable name "tf" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/tokenizer.py:102:20: C0103: Variable name "ch" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/verilog/tokenizer.py:118:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:123:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/parsers/verilog/tokenizer.py:135:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:139:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:146:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:154:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/tokenizer.py:155:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/verilog/tokenizer.py:5:0: W0611: Unused import re (unused-import)
************* Module spydrnet.parsers.verilog.verilog_token_factory
spydrnet/parsers/verilog/verilog_token_factory.py:13:0: C0301: Line too long (114/100) (line-too-long)
spydrnet/parsers/verilog/verilog_token_factory.py:117:0: C0301: Line too long (114/100) (line-too-long)
spydrnet/parsers/verilog/verilog_token_factory.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/verilog/verilog_token_factory.py:4:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/parsers/verilog/verilog_token_factory.py:15:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/verilog_token_factory.py:18:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/verilog_token_factory.py:27:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/verilog_token_factory.py:44:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/verilog/verilog_token_factory.py:121:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module spydrnet.parsers.edif.edif_tokens
spydrnet/parsers/edif/edif_tokens.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module spydrnet.parsers.edif.parser
spydrnet/parsers/edif/parser.py:1017:0: C0301: Line too long (109/100) (line-too-long)
spydrnet/parsers/edif/parser.py:1031:0: C0301: Line too long (115/100) (line-too-long)
spydrnet/parsers/edif/parser.py:1:0: C0302: Too many lines in module (1228/1000) (too-many-lines)
spydrnet/parsers/edif/parser.py:462:21: W0511: TODO: what about multi-dimensional ports, non-downto ports, and when (fixme)
spydrnet/parsers/edif/parser.py:478:13: W0511: TODO: what about single pin array ports with a non_zero starting index. (fixme)
spydrnet/parsers/edif/parser.py:571:21: W0511: TODO: Add warning about merging nets together (fixme)
spydrnet/parsers/edif/parser.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/edif/parser.py:5:0: W0401: Wildcard import spydrnet.parsers.edif.edif_tokens (wildcard-import)
spydrnet/parsers/edif/parser.py:10:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/parsers/edif/parser.py:11:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:18:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:24:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:36:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:42:8: C2801: Unnecessarily calls dunder method __del__. Use del keyword. (unnecessary-dunder-call)
spydrnet/parsers/edif/parser.py:44:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:50:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:59:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:64:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:64:4: C0103: Method name "parse_edifVersion" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:73:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:73:4: C0103: Method name "parse_edifLevel" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:81:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:81:4: C0103: Method name "parse_keywordMap" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:90:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:90:4: C0103: Method name "parse_keywordLevel" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:98:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:125:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:136:38: E1131: unsupported operand type(s) for | (unsupported-binary-operation)
spydrnet/parsers/edif/parser.py:136:38: E1131: unsupported operand type(s) for | (unsupported-binary-operation)
spydrnet/parsers/edif/parser.py:140:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:147:8: C0103: Variable name "has_dataOrigin" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:158:16: C0103: Variable name "has_dataOrigin" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:185:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:185:4: C0103: Method name "parse_timeStamp" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:197:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:204:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:219:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:223:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:227:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:249:16: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:257:28: W0707: Consider explicitly re-raising using 'except ValueError as exc' and 'raise e from exc' (raise-missing-from)
spydrnet/parsers/edif/parser.py:272:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:276:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:276:4: C0103: Method name "parse_numberDefinition" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:280:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:289:8: C0103: Variable name "has_viewMap" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:298:16: C0103: Variable name "has_viewMap" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:315:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:315:4: C0103: Method name "parse_cellType" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:330:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:359:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:359:4: C0103: Method name "parse_viewType" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:363:12: R0916: Too many boolean expressions in if statement (10/5) (too-many-boolean-expressions)
spydrnet/parsers/edif/parser.py:396:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:396:4: R0912: Too many branches (19/12) (too-many-branches)
spydrnet/parsers/edif/parser.py:442:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:446:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:446:4: R0912: Too many branches (21/12) (too-many-branches)
spydrnet/parsers/edif/parser.py:446:4: R0915: Too many statements (59/50) (too-many-statements)
spydrnet/parsers/edif/parser.py:516:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:524:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:538:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:547:16: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:555:28: W0707: Consider explicitly re-raising using 'except ValueError as exc' and 'raise e from exc' (raise-missing-from)
spydrnet/parsers/edif/parser.py:570:16: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:538:4: R0912: Too many branches (29/12) (too-many-branches)
spydrnet/parsers/edif/parser.py:538:4: R0915: Too many statements (68/50) (too-many-statements)
spydrnet/parsers/edif/parser.py:570:16: W0612: Unused variable 'e' (unused-variable)
spydrnet/parsers/edif/parser.py:624:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:652:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:652:4: C0103: Method name "parse_viewRef" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:663:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/parsers/edif/parser.py:673:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:673:4: C0103: Method name "parse_cellRef" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:694:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:694:4: C0103: Method name "parse_libraryRef" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:713:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:733:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:748:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:748:4: C0103: Method name "parse_portRef" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:762:12: R1720: Unnecessary "elif" after "raise", remove the leading "el" from "elif" (no-else-raise)
spydrnet/parsers/edif/parser.py:794:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:794:4: C0103: Method name "parse_instanceRef" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:798:8: R1720: Unnecessary "else" after "raise", remove the "else" and de-indent the code inside it (no-else-raise)
spydrnet/parsers/edif/parser.py:801:12: W0101: Unreachable code (unreachable)
spydrnet/parsers/edif/parser.py:816:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:825:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:825:4: C0103: Method name "parse_viewMap" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:829:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:853:26: W0631: Using possibly undefined loop variable 'library' (undefined-loop-variable)
spydrnet/parsers/edif/parser.py:856:29: W0631: Using possibly undefined loop variable 'definition' (undefined-loop-variable)
spydrnet/parsers/edif/parser.py:861:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:861:4: C0103: Method name "parse_dataOrigin" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:865:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:865:4: C0103: Method name "parse_userData" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:869:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:879:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:884:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:889:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:928:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:928:4: C0103: Method name "parse_typedValue" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:943:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:956:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:960:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:969:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:976:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:980:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:984:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:987:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:987:4: C0103: Method name "parse_nameRef" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:992:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:992:4: C0103: Method name "parse_nameDef" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:1001:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1001:4: R0914: Too many local variables (19/15) (too-many-locals)
spydrnet/parsers/edif/parser.py:1035:24: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:1036:24: C0103: Variable name "ew" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:1039:28: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:1063:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1079:35: W0631: Using possibly undefined loop variable 'i' (undefined-loop-variable)
spydrnet/parsers/edif/parser.py:1110:35: W0631: Using possibly undefined loop variable 'i' (undefined-loop-variable)
spydrnet/parsers/edif/parser.py:1113:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1124:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1129:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1129:4: C0103: Method name "parse_stringToken" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:1134:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1134:4: C0103: Method name "parse_integerToken" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/parser.py:1139:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1143:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1148:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1152:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1155:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1167:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1174:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1183:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1186:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/parsers/edif/parser.py:1192:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1197:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1202:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1207:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1211:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:1217:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/parser.py:40:8: W0201: Attribute 'netlist' defined outside __init__ (attribute-defined-outside-init)
spydrnet/parsers/edif/parser.py:10:0: R0904: Too many public methods (79/20) (too-many-public-methods)
************* Module spydrnet.parsers.edif.tokenizer
spydrnet/parsers/edif/tokenizer.py:193:0: C0301: Line too long (179/100) (line-too-long)
spydrnet/parsers/edif/tokenizer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/edif/tokenizer.py:8:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/parsers/edif/tokenizer.py:10:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:15:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:21:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:32:16: W0622: Redefining built-in 'zip' (redefined-builtin)
spydrnet/parsers/edif/tokenizer.py:39:36: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/parsers/edif/tokenizer.py:49:36: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/parsers/edif/tokenizer.py:42:22: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/parsers/edif/tokenizer.py:45:25: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/parsers/edif/tokenizer.py:49:36: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/parsers/edif/tokenizer.py:62:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:69:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:77:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:78:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/edif/tokenizer.py:84:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:90:20: C0103: Variable name "ch" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/tokenizer.py:84:4: R0912: Too many branches (15/12) (too-many-branches)
spydrnet/parsers/edif/tokenizer.py:126:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:130:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:133:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/parsers/edif/tokenizer.py:138:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:142:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:146:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:147:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/edif/tokenizer.py:151:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
spydrnet/parsers/edif/tokenizer.py:157:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:160:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/parsers/edif/tokenizer.py:165:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:170:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:170:4: C0103: Method name "expect_valid_integerToken" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/tokenizer.py:173:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/parsers/edif/tokenizer.py:178:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:178:4: C0103: Method name "is_valid_integerToken" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/tokenizer.py:183:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:183:4: C0103: Method name "expect_valid_stringToken" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/edif/tokenizer.py:186:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/parsers/edif/tokenizer.py:191:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/edif/tokenizer.py:191:4: C0103: Method name "is_valid_stringToken" doesn't conform to snake_case naming style (invalid-name)
************* Module spydrnet.parsers.eblif.eblif_parser
spydrnet/parsers/eblif/eblif_parser.py:296:0: C0301: Line too long (121/100) (line-too-long)
spydrnet/parsers/eblif/eblif_parser.py:297:0: C0301: Line too long (103/100) (line-too-long)
spydrnet/parsers/eblif/eblif_parser.py:491:0: C0301: Line too long (109/100) (line-too-long)
spydrnet/parsers/eblif/eblif_parser.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/eblif/eblif_parser.py:12:0: R0902: Too many instance attributes (11/7) (too-many-instance-attributes)
spydrnet/parsers/eblif/eblif_parser.py:28:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/eblif/eblif_parser.py:43:16: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/eblif/eblif_parser.py:52:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:58:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:76:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:82:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:87:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:103:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:109:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:137:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:149:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:157:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:175:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:201:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:206:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:217:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:230:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:251:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:264:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:293:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:312:62: W0640: Cell variable port_name defined in loop (cell-var-from-loop)
spydrnet/parsers/eblif/eblif_parser.py:313:61: W0640: Cell variable pin_index defined in loop (cell-var-from-loop)
spydrnet/parsers/eblif/eblif_parser.py:318:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:326:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:329:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:333:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/eblif/eblif_parser.py:352:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:355:19: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
spydrnet/parsers/eblif/eblif_parser.py:364:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:379:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:389:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:395:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:405:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:453:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:460:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:466:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:481:25: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
spydrnet/parsers/eblif/eblif_parser.py:501:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:511:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:527:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:572:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:576:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:580:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_parser.py:581:12: C0103: Variable name "d" doesn't conform to snake_case naming style (invalid-name)
spydrnet/parsers/eblif/eblif_parser.py:12:0: R0904: Too many public methods (37/20) (too-many-public-methods)
************* Module spydrnet.parsers.eblif.eblif_tokenizer
spydrnet/parsers/eblif/eblif_tokenizer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:7:0: C0115: Missing class docstring (missing-class-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:9:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:14:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:20:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:39:36: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/parsers/eblif/eblif_tokenizer.py:41:32: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
spydrnet/parsers/eblif/eblif_tokenizer.py:32:25: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/parsers/eblif/eblif_tokenizer.py:35:25: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/parsers/eblif/eblif_tokenizer.py:41:32: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
spydrnet/parsers/eblif/eblif_tokenizer.py:50:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:67:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:83:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:84:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/eblif/eblif_tokenizer.py:90:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:93:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
spydrnet/parsers/eblif/eblif_tokenizer.py:98:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:101:4: C0116: Missing function or method docstring (missing-function-docstring)
spydrnet/parsers/eblif/eblif_tokenizer.py:102:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
spydrnet/parsers/eblif/eblif_tokenizer.py:106:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
************* Module spydrnet.parsers.eblif.eblif_tokens
spydrnet/parsers/eblif/eblif_tokens.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module spydrnet.parsers.eblif.__init__
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[337:390]
==spydrnet.util.get_hwires:[353:406]
                    search_stack += (
                        x for x in _get_hpins_from_hwire(hwire_outside) if x != hpin
                    )


def _get_inner_hwire_from_hpin(hpin):
    wire = hpin.item.wire
    if wire:
        cable = wire.cable
        if cable:
            hport = hpin.parent
            hinst = hport.parent
            hcable = HRef.from_parent_and_item(hinst, cable)
            hwire = HRef.from_parent_and_item(hcable, wire)
            return hwire


def _get_outer_hwire_from_hpin(hpin):
    hport = hpin.parent
    hinst = hport.parent
    instance = hinst.item
    pin = hpin.item
    if pin in instance.pins:
        outer_pin = instance.pins[hpin.item]
        outer_wire = outer_pin.wire
        if outer_wire:
            cable = outer_wire.cable
            if cable:
                hcable = HRef.from_parent_and_item(hinst.parent, cable)
                hwire = HRef.from_parent_and_item(hcable, outer_wire)
                return hwire


def _get_hpins_from_hwire(hwire):
    hcable = hwire.parent
    hinst = hcable.parent
    for pin in hwire.item.pins:
        if isinstance(pin, InnerPin):
            port = pin.port
            if port:
                hport = HRef.from_parent_and_item(hinst, port)
                hpin = HRef.from_parent_and_item(hport, pin)
                yield hpin
        else:
            instance = pin.instance
            inner_pin = pin.inner_pin
            if instance and inner_pin:
                port = inner_pin.port
                if port:
                    other_hinst = HRef.from_parent_and_item(hinst, instance)
                    other_hport = HRef.from_parent_and_item(other_hinst, port)
                    other_hpin = HRef.from_parent_and_item(other_hport, inner_pin)
                    yield other_hpin (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[62:111]
==spydrnet.util.get_hwires:[62:111]
    if len(args) == 1 and "patterns" in kwargs:
        raise TypeError("get_hwires() got multiple values for argument 'patterns'")
    if len(args) > 1 or any(
        x not in {"patterns", "selection", "recursive", "filter", "is_case", "is_re"}
        for x in kwargs
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection]
    if isinstance(selection, Selection) is False:
        raise TypeError(
            "selection must be '{}'".format("', '".join(Selection.__members__.keys()))
        )

    filter_func = kwargs.get("filter", lambda x: True)
    recursive = kwargs.get("recursive", False)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )

    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if (
        all(
            isinstance(x, (HRef, FirstClassElement, InnerPin, OuterPin, Wire))
            for x in object_collection
        )
        is False
    ):
        raise TypeError(
            "get_hwires() supports all netlist related objects and hierarchical references or a "
            "collection of theses as the object searched, unsupported object provided"
        )

    if isinstance(patterns, str):
        patterns = (patterns,)
    assert isinstance(patterns, (FirstClassElement, InnerPin, OuterPin, Wire)) is False
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.edif.tokenizer:[22:69]
==spydrnet.parsers.verilog.tokenizer:[27:74]
        return tokenizer

    def __init__(self, input_source):
        self.token = None
        self.next_token = None
        self.line_number = 0

        if isinstance(input_source, str):
            if zipfile.is_zipfile(input_source):
                zip = zipfile.ZipFile(input_source)
                filename = Path(input_source).name
                filename = filename[: filename.rindex(".")]
                stream = zip.open(filename)
                stream = io.TextIOWrapper(stream)
                self.input_stream = stream
            else:
                self.input_stream = open(input_source, "r")
        elif isinstance(input_source, Path):
            if zipfile.is_zipfile(input_source):
                zip = zipfile.ZipFile(input_source)
                filename = Path(input_source).name
                filename = filename[: filename.rindex(".")]
                stream = zip.open(filename)
                stream = io.TextIOWrapper(stream)
                self.input_stream = stream
            else:
                self.input_stream = open(input_source, "r")
        else:
            if isinstance(input_source, io.TextIOBase) is False:
                self.input_stream = io.TextIOWrapper(input_source)
            else:
                self.input_stream = input_source

        self.generator = self.generate_tokens()

    def __del__(self):
        if hasattr(self, "input_stream"):
            self.close()

    def has_next(self):
        try:
            self.peek()
            return True
        except StopIteration:
            return False

    def next(self): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[207:245]
==spydrnet.util.get_hwires:[269:307]
    for href in in_yield:
        in_namemap.discard(href)

    if in_namemap:  # namemap is to cable
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern]
                    for href in result:
                        if href in in_namemap:
                            in_namemap.remove(href)
                            yield href
            else:
                for name in namemap:
                    if _value_matches_pattern(name, pattern, is_case, is_re):
                        result = namemap[name]
                        for href in result:
                            if href in in_namemap:
                                in_namemap.remove(href)
                                yield href


def _update_hwire_namemap(href_instance, recursive, found, namemap):
    search_stack = [(href_instance, False)]
    name_stack = []
    while search_stack:
        href_instance, visited = search_stack.pop()
        if visited:
            name_stack.pop()
        else:
            search_stack.append((href_instance, True))
            name_stack.append(
                href_instance.item.name if href_instance.item.name else ""
            )
            item = href_instance.item
            reference = item.reference
            if reference: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[74:112]
==spydrnet.util.get_libraries:[73:111]
    if len(args) > 1 or any(
        x
        not in {
            "patterns",
            "key",
            "filter",
            "is_case",
            "is_re",
            "selection",
            "recursive",
        }
        for x in kwargs
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection]
    if selection not in {Selection.INSIDE, Selection.OUTSIDE}:
        raise TypeError(
            "selection must be '{}'".format(
                "', '".join([Selection.INSIDE.name, Selection.OUTSIDE.name])
            )
        )

    filter_func = kwargs.get("filter", lambda x: True)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )
    key = kwargs.get("key", ".NAME")
    recursive = kwargs.get("recursive", False)

    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_definitions:[72:108]
==spydrnet.util.get_libraries:[73:109]
    if len(args) > 1 or any(
        x
        not in {
            "patterns",
            "key",
            "filter",
            "is_case",
            "is_re",
            "selection",
            "recursive",
        }
        for x in kwargs
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection]
    if selection not in {Selection.INSIDE, Selection.OUTSIDE}:
        raise TypeError(
            "selection must be '{}'".format(
                "', '".join([Selection.INSIDE.name, Selection.OUTSIDE.name])
            )
        )

    filter_func = kwargs.get("filter", lambda x: True)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )
    key = kwargs.get("key", ".NAME")
    recursive = kwargs.get("recursive", False)
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[194:230]
==spydrnet.util.get_hports:[187:223]
        elif isinstance(obj, Library):
            object_collection += obj.definitions
        elif isinstance(obj, Definition):
            hrefs = set(HRef.get_all_hrefs_of_instances(obj.references))
            bypass_namesearch |= hrefs
            object_collection += hrefs
        elif isinstance(obj, Instance):
            hrefs = set(HRef.get_all_hrefs_of_instances(obj))
            bypass_namesearch |= hrefs
            object_collection += hrefs
        elif isinstance(obj, (Port, Cable, InnerPin, OuterPin, Wire)):
            object_collection += HRef.get_all_hrefs_of_item(obj)

    for href in in_yield:
        in_namemap.discard(href)

    if in_namemap:  # namemap is to cable
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern]
                    for href in result:
                        if href in in_namemap:
                            in_namemap.remove(href)
                            yield href
            else:
                for name in namemap:
                    if _value_matches_pattern(name, pattern, is_case, is_re):
                        result = namemap[name]
                        for href in result:
                            if href in in_namemap:
                                in_namemap.remove(href)
                                yield href

 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[80:111]
==spydrnet.util.get_hpins:[66:97]
    filter_func = kwargs.get("filter", lambda x: True)
    recursive = kwargs.get("recursive", False)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )

    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if (
        all(
            isinstance(x, (HRef, FirstClassElement, InnerPin, OuterPin, Wire))
            for x in object_collection
        )
        is False
    ):
        raise TypeError(
            "get_hwires() supports all netlist related objects and hierarchical references or a "
            "collection of theses as the object searched, unsupported object provided"
        )

    if isinstance(patterns, str):
        patterns = (patterns,)
    assert isinstance(patterns, (FirstClassElement, InnerPin, OuterPin, Wire)) is False
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[60:89]
==spydrnet.util.get_hports:[60:89]
    if len(args) > 1 or any(
        x not in {"patterns", "recursive", "filter", "is_case", "is_re"} for x in kwargs
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    filter_func = kwargs.get("filter", lambda x: True)
    recursive = kwargs.get("recursive", False)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )

    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if (
        all(
            isinstance(x, (HRef, FirstClassElement, InnerPin, OuterPin, Wire))
            for x in object_collection
        )
        is False
    ):
        raise TypeError( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[160:185]
==spydrnet.util.get_hwires:[162:187]
                            if recursive or selection == Selection.ALL:
                                for child in reference.children:
                                    href_child = HRef.from_parent_and_item(obj, child)
                                    bypass_namesearch.add(href_child)
                                    object_collection.append(href_child)
                        if selection in {
                            Selection.OUTSIDE,
                            Selection.BOTH,
                            Selection.ALL,
                        }:
                            for port in reference.ports:
                                href_port = HRef.from_parent_and_item(obj, port)
                                for pin in port.pins:
                                    href_pin = HRef.from_parent_and_item(href_port, pin)
                                    hpin_search.add(href_pin)
            elif isinstance(item, Port):
                for pin in item.pins:
                    href_pin = HRef.from_parent_and_item(obj, pin)
                    hpin_search.add(href_pin)
            elif isinstance(item, Cable):
                for wire in item.wires:
                    href_wire = HRef.from_parent_and_item(obj, wire)
                    object_collection.append(href_wire)
            elif isinstance(item, Wire):
                if selection == Selection.INSIDE: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hinstances:[66:89]
==spydrnet.util.get_hwires:[80:103]
    filter_func = kwargs.get("filter", lambda x: True)
    recursive = kwargs.get("recursive", False)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )

    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if (
        all(
            isinstance(x, (HRef, FirstClassElement, InnerPin, OuterPin, Wire))
            for x in object_collection
        )
        is False
    ):
        raise TypeError( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[237:259]
==spydrnet.util.get_libraries:[252:274]
            if other_instance in found:
                continue
            found.add(other_instance)
            name = other_instance[key] if key in other_instance else ""
            if name not in namemap:
                namemap[name] = []
            namemap[name].append(other_instance)
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern]
                    for instance in result:
                        yield instance
            else:
                discard = set()
                for instance in found:
                    value = instance[key] if key in instance else ""
                    if _value_matches_pattern(value, pattern, is_case, is_re):
                        discard.add(instance)
                        yield instance
                found -= discard (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[235:258]
==spydrnet.util.get_hwires:[242:265]
                            href_pin = HRef.from_parent_and_item(href_port, pin)
                        else:
                            port = pin.port
                            href_port = HRef.from_parent_and_item(href_inst, port)
                            href_pin = HRef.from_parent_and_item(href_port, pin)
                        object_collection.append(href_pin)
            elif isinstance(item, InnerPin):
                hpin_search.add(obj)
        elif isinstance(obj, Library):
            object_collection += obj.definitions
        elif isinstance(obj, Definition):
            hrefs = set(HRef.get_all_hrefs_of_instances(obj.references))
            bypass_namesearch |= hrefs
            object_collection += hrefs
        elif isinstance(obj, Instance):
            hrefs = set(HRef.get_all_hrefs_of_instances(obj))
            bypass_namesearch |= hrefs
            object_collection += hrefs
        elif isinstance(obj, (Port, Cable, InnerPin, OuterPin, Wire)):
            object_collection += HRef.get_all_hrefs_of_item(obj)

    if hpin_search:
        for hwire in _get_hwires_from_hpins(hpin_search, selection): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[80:103]
==spydrnet.util.get_hports:[66:89]
    filter_func = kwargs.get("filter", lambda x: True)
    recursive = kwargs.get("recursive", False)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )

    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if (
        all(
            isinstance(x, (HRef, FirstClassElement, InnerPin, OuterPin, Wire))
            for x in object_collection
        )
        is False
    ):
        raise TypeError( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[153:174]
==spydrnet.util.get_hports:[149:170]
            elif isinstance(item, Cable):
                for wire in item.wires:
                    href_wire = HRef.from_parent_and_item(obj, wire)
                    object_collection.append(href_wire)
            elif isinstance(item, Wire):
                href_parent_cable = obj.parent
                href_parent_instance = href_parent_cable.parent
                for pin in item.pins:
                    if isinstance(pin, OuterPin):
                        instance = pin.instance
                        if instance:
                            href_inst = HRef.from_parent_and_item(
                                href_parent_instance, pin.instance
                            )
                            inner_pin = pin.inner_pin
                            if inner_pin:
                                inner_port = inner_pin.port
                                if inner_port:
                                    href_port = HRef.from_parent_and_item(
                                        href_inst, inner_port
                                    ) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_netlists:[61:84]
==spydrnet.util.get_ports:[62:85]
    if len(args) > 1 or any(
        x not in {"patterns", "key", "filter", "is_case", "is_re"} for x in kwargs
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    filter_func = kwargs.get("filter", lambda x: True)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )
    key = kwargs.get("key", ".NAME")

    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if all(isinstance(x, (Element, HRef)) for x in object_collection) is False:
        raise TypeError( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[66:88]
==spydrnet.util.get_instances:[72:94]
    if len(args) == 1 and "patterns" in kwargs:
        raise TypeError("get_cables() got multiple values for argument 'patterns'")
    if len(args) > 1 or any(
        x
        not in {
            "patterns",
            "key",
            "filter",
            "is_case",
            "is_re",
            "selection",
            "recursive",
        }
        for x in kwargs
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hports:[200:223]
==spydrnet.util.get_hwires:[269:292]
    for href in in_yield:
        in_namemap.discard(href)

    if in_namemap:  # namemap is to cable
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern]
                    for href in result:
                        if href in in_namemap:
                            in_namemap.remove(href)
                            yield href
            else:
                for name in namemap:
                    if _value_matches_pattern(name, pattern, is_case, is_re):
                        result = namemap[name]
                        for href in result:
                            if href in in_namemap:
                                in_namemap.remove(href)
                                yield href

 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[263:286]
==spydrnet.util.get_hpins:[207:230]
    for href in in_yield:
        in_namemap.discard(href)

    if in_namemap:  # namemap is to cable
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern]
                    for href in result:
                        if href in in_namemap:
                            in_namemap.remove(href)
                            yield href
            else:
                for name in namemap:
                    if _value_matches_pattern(name, pattern, is_case, is_re):
                        result = namemap[name]
                        for href in result:
                            if href in in_namemap:
                                in_namemap.remove(href)
                                yield href

 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[91:111]
==spydrnet.util.get_definitions:[97:117]
        )

    filter_func = kwargs.get("filter", lambda x: True)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )
    key = kwargs.get("key", ".NAME")
    recursive = kwargs.get("recursive", False)

    if isinstance(obj, (Element, HRef)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if all(isinstance(x, (Element, HRef)) for x in object_collection) is False:
        raise TypeError( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[272:290]
==spydrnet.util.get_ports:[161:179]
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern]
                    del namemap[pattern]
                    for port in result:
                        yield port
            else:
                names_to_remove = []
                for name in namemap:
                    if _value_matches_pattern(name, pattern, is_case, is_re):
                        result = namemap[name]
                        names_to_remove.append(name)
                        for port in result:
                            yield port
                for name in names_to_remove:
                    del namemap[name] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[68:88]
==spydrnet.util.get_libraries:[73:93]
    if len(args) > 1 or any(
        x
        not in {
            "patterns",
            "key",
            "filter",
            "is_case",
            "is_re",
            "selection",
            "recursive",
        }
        for x in kwargs
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[287:305]
==spydrnet.util.get_hwires:[293:311]
    search_stack = [(href_instance, False)]
    name_stack = []
    while search_stack:
        href_instance, visited = search_stack.pop()
        if visited:
            name_stack.pop()
        else:
            search_stack.append((href_instance, True))
            name_stack.append(
                href_instance.item.name if href_instance.item.name else ""
            )
            item = href_instance.item
            reference = item.reference
            if reference:
                for cable in reference.cables:
                    hcable = HRef.from_parent_and_item(href_instance, cable)
                    name_stack.append(cable.name if cable.name else "")
                    cable_hname = "/".join(name_stack[1:]) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[129:147]
==spydrnet.util.get_hwires:[129:147]
    in_namemap = set()
    in_yield = set()
    namemap = {}
    hpin_search = set()
    bypass_namesearch = set()
    while object_collection:
        obj = object_collection.pop()
        if isinstance(obj, Netlist):
            top_instance = obj.top_instance
            if top_instance:
                href = HRef.from_parent_and_item(None, top_instance)
                object_collection.append(href)
        elif isinstance(obj, HRef):
            if obj.is_valid is False:
                continue
            item = obj.item
            if isinstance(item, Instance):
                if selection == Selection.INSIDE and obj not in bypass_namesearch: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[231:249]
==spydrnet.util.get_hports:[224:242]
    search_stack = [(href_instance, False)]
    name_stack = []
    while search_stack:
        href_instance, visited = search_stack.pop()
        if visited:
            name_stack.pop()
        else:
            search_stack.append((href_instance, True))
            name_stack.append(
                href_instance.item.name if href_instance.item.name else ""
            )
            item = href_instance.item
            reference = item.reference
            if reference:
                for port in reference.ports:
                    hport = HRef.from_parent_and_item(href_instance, port)
                    name_stack.append(port.name if port.name else "")
                    port_hname = "/".join(name_stack[1:]) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[111:128]
==spydrnet.util.get_hports:[111:128]
    in_namemap = set()
    in_yield = set()
    namemap = {}
    bypass_namesearch = set()
    while object_collection:
        obj = object_collection.pop()
        if isinstance(obj, Netlist):
            top_instance = obj.top_instance
            if top_instance:
                href = HRef.from_parent_and_item(None, top_instance)
                object_collection.append(href)
        elif isinstance(obj, HRef):
            if obj.is_valid is False:
                continue
            item = obj.item
            if isinstance(item, Instance):
                if obj not in bypass_namesearch: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[310:328]
==spydrnet.util.get_hwires:[324:342]
                    name_stack.pop()
                if recursive:
                    for child in reference.children:
                        if child.reference and child.reference.is_leaf() is False:
                            href_child = HRef.from_parent_and_item(href_instance, child)
                            search_stack.append((href_child, False))


def _get_hwires_from_hpins(hpin_search, selection):
    found_hwires = set()
    search_stack = list(hpin_search)
    while search_stack:
        hpin = search_stack.pop()
        if selection in {Selection.INSIDE, Selection.BOTH, Selection.ALL}:
            hwire_inside = _get_inner_hwire_from_hpin(hpin)
            if hwire_inside and hwire_inside not in found_hwires:
                found_hwires.add(hwire_inside)
                yield hwire_inside (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[0:17]
==spydrnet.util.get_hwires:[0:17]
from spydrnet import (
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef
from spydrnet.util.selection import Selection
from spydrnet.util.patterns import _is_pattern_absolute, _value_matches_pattern

 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hports:[224:238]
==spydrnet.util.get_hwires:[293:307]
    search_stack = [(href_instance, False)]
    name_stack = []
    while search_stack:
        href_instance, visited = search_stack.pop()
        if visited:
            name_stack.pop()
        else:
            search_stack.append((href_instance, True))
            name_stack.append(
                href_instance.item.name if href_instance.item.name else ""
            )
            item = href_instance.item
            reference = item.reference
            if reference: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[189:203]
==spydrnet.util.get_hwires:[190:204]
                elif selection == Selection.OUTSIDE:
                    href_parent_cable = obj.parent
                    href_parent_instance = href_parent_cable.parent
                    for pin in item.pins:
                        if isinstance(pin, OuterPin):
                            href_inst = HRef.from_parent_and_item(
                                href_parent_instance, pin.instance
                            )
                            inner_wire = pin.inner_pin.wire
                            if inner_wire:
                                inner_cable = inner_wire.cable
                                href_cable = HRef.from_parent_and_item(
                                    href_inst, inner_cable
                                ) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[0:16]
==spydrnet.util.get_hports:[0:16]
from spydrnet import (
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef
from spydrnet.util.patterns import _is_pattern_absolute, _value_matches_pattern

 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[287:301]
==spydrnet.util.get_hpins:[231:245]
    search_stack = [(href_instance, False)]
    name_stack = []
    while search_stack:
        href_instance, visited = search_stack.pop()
        if visited:
            name_stack.pop()
        else:
            search_stack.append((href_instance, True))
            name_stack.append(
                href_instance.item.name if href_instance.item.name else ""
            )
            item = href_instance.item
            reference = item.reference
            if reference: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_parser:[31:52]
==spydrnet.parsers.verilog.parser:[56:77]
                definition.name = name
                self.name_lookup[name] = definition
                return definition

        def define(self, name):
            """adds the name to the defined set"""
            self.defined.add(self.name_lookup[name])

        def get_undefined_blackboxes(self):
            """return an iterable of all undefined blackboxes"""
            undef = set()
            for v in self.name_lookup.values():
                if v not in self.defined:
                    undef.add(v)
            return undef

    #######################################################
    # setup functions
    #######################################################
    @staticmethod
    def from_filename(filename): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hports:[114:127]
==spydrnet.util.get_hwires:[133:146]
    bypass_namesearch = set()
    while object_collection:
        obj = object_collection.pop()
        if isinstance(obj, Netlist):
            top_instance = obj.top_instance
            if top_instance:
                href = HRef.from_parent_and_item(None, top_instance)
                object_collection.append(href)
        elif isinstance(obj, HRef):
            if obj.is_valid is False:
                continue
            item = obj.item
            if isinstance(item, Instance): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hports:[0:13]
==spydrnet.util.get_hwires:[0:13]
from spydrnet import (
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[133:146]
==spydrnet.util.get_hpins:[114:127]
    bypass_namesearch = set()
    while object_collection:
        obj = object_collection.pop()
        if isinstance(obj, Netlist):
            top_instance = obj.top_instance
            if top_instance:
                href = HRef.from_parent_and_item(None, top_instance)
                object_collection.append(href)
        elif isinstance(obj, HRef):
            if obj.is_valid is False:
                continue
            item = obj.item
            if isinstance(item, Instance): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[0:13]
==spydrnet.util.get_hpins:[0:13]
from spydrnet import (
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_tokenizer:[59:73]
==spydrnet.parsers.edif.tokenizer:[61:74]
    def has_next(self):
        try:
            self.peek()
            return True
        except StopIteration:
            return False

    def next(self):
        if self.next_token:
            self.token = self.next_token
            self.next_token = None
        else:
            self.token = next(self.generator)
        # print(self.token) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[1:13]
==spydrnet.util.get_ports:[1:13]
    Element,
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable,
) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_libraries:[86:101]
==spydrnet.util.get_pins:[46:62]
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection]
    if selection not in {Selection.INSIDE, Selection.OUTSIDE}:
        raise TypeError(
            "selection must be '{}'".format(
                "', '".join([Selection.INSIDE.name, Selection.OUTSIDE.name])
            )
        )

    filter_func = kwargs.get("filter", lambda x: True)
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hports:[187:200]
==spydrnet.util.get_hwires:[250:263]
        elif isinstance(obj, Library):
            object_collection += obj.definitions
        elif isinstance(obj, Definition):
            hrefs = set(HRef.get_all_hrefs_of_instances(obj.references))
            bypass_namesearch |= hrefs
            object_collection += hrefs
        elif isinstance(obj, Instance):
            hrefs = set(HRef.get_all_hrefs_of_instances(obj))
            bypass_namesearch |= hrefs
            object_collection += hrefs
        elif isinstance(obj, (Port, Cable, InnerPin, OuterPin, Wire)):
            object_collection += HRef.get_all_hrefs_of_item(obj)
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[2:14]
==spydrnet.util.get_pins:[2:16]
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef
from spydrnet.util.selection import Selection

 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[67:82]
==spydrnet.util.get_wires:[49:65]
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection]
    if isinstance(selection, Selection) is False:
        raise TypeError(
            "selection must be '{}'".format("', '".join(Selection.__members__.keys()))
        )

    filter_func = kwargs.get("filter", lambda x: True)
    recursive = kwargs.get("recursive", False)
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[206:218]
==spydrnet.util.get_hwires:[210:222]
                        else:
                            href_parent = href_parent_instance.parent
                            if href_parent:
                                instance = href_parent_instance.item
                                if pin in instance.pins:
                                    outer_pin = instance.pins[pin]
                                    outer_wire = outer_pin.wire
                                    if outer_wire:
                                        outer_cable = outer_wire.cable
                                        href_cable = HRef.from_parent_and_item(
                                            href_parent, outer_cable
                                        ) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[79:94]
==spydrnet.util.get_hcables:[66:81]
        for x in kwargs
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection]
    if isinstance(selection, Selection) is False:
        raise TypeError(
            "selection must be '{}'".format("', '".join(Selection.__members__.keys()))
        )

    filter_func = kwargs.get("filter", lambda x: True) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[1:13]
==spydrnet.util.get_ports:[2:14]
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[243:256]
==spydrnet.util.get_hpins:[194:207]
        elif isinstance(obj, Library):
            object_collection += obj.definitions
        elif isinstance(obj, Definition):
            hrefs = set(HRef.get_all_hrefs_of_instances(obj.references))
            bypass_namesearch |= hrefs
            object_collection += hrefs
        elif isinstance(obj, Instance):
            hrefs = set(HRef.get_all_hrefs_of_instances(obj))
            bypass_namesearch |= hrefs
            object_collection += hrefs
        elif isinstance(obj, (Port, Cable, InnerPin, OuterPin, Wire)):
            object_collection += HRef.get_all_hrefs_of_item(obj)
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_pins:[63:75]
==spydrnet.util.get_ports:[77:89]
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if all(isinstance(x, (Element, HRef)) for x in object_collection) is False:
        raise TypeError(
            "get_ports() supports netlist elements and hierarchical references, or a collection of "
            "these as the object searched"
        )
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[80:94]
==spydrnet.util.get_wires:[49:63]
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection]
    if isinstance(selection, Selection) is False:
        raise TypeError(
            "selection must be '{}'".format("', '".join(Selection.__members__.keys()))
        )

    filter_func = kwargs.get("filter", lambda x: True) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[2:13]
==spydrnet.util.get_pins:[2:13]
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[1:12]
==spydrnet.util.get_instances:[2:13]
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable,
) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[3:13]
==spydrnet.util.get_pins:[2:12]
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable,
) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[67:77]
==spydrnet.plugins.namespace_manager.edif_namespace:[102:112]
                    else:
                        return False
            namespace.clear()
            for instance in element.children:
                if ".NAME" in instance:
                    name = instance[".NAME"]
                    if name not in namespace:
                        namespace.add(name)
                    else:
                        return False (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[59:69]
==spydrnet.plugins.namespace_manager.edif_namespace:[88:98]
                    else:
                        return False
            namespace.clear()
            for cable in element.cables:
                if ".NAME" in cable:
                    name = cable[".NAME"]
                    if name not in namespace:
                        namespace.add(name)
                    else:
                        return False (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[51:61]
==spydrnet.plugins.namespace_manager.edif_namespace:[74:84]
                    else:
                        return False
        elif isinstance(element, Definition):
            for port in element.ports:
                if ".NAME" in port:
                    name = port[".NAME"]
                    if name not in namespace:
                        namespace.add(name)
                    else:
                        return False (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[43:53]
==spydrnet.plugins.namespace_manager.edif_namespace:[60:70]
                    else:
                        return False
        elif isinstance(element, Library):
            for definition in element.definitions:
                if ".NAME" in definition:
                    name = definition[".NAME"]
                    if name not in namespace:
                        namespace.add(name)
                    else:
                        return False (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_tokenizer:[101:110]
==spydrnet.parsers.edif.tokenizer:[146:156]
        if this == that:
            return True
        else:
            lowercase_this = this.lower()
            if lowercase_this == that:
                return True
            elif lowercase_this == that.lower():
                return True
        return False (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.edif.tokenizer:[30:39]
==spydrnet.parsers.verilog.tokenizer:[45:54]
            if zipfile.is_zipfile(input_source):
                zip = zipfile.ZipFile(input_source)
                filename = Path(input_source).name
                filename = filename[: filename.rindex(".")]
                stream = zip.open(filename)
                stream = io.TextIOWrapper(stream)
                self.input_stream = stream
            else:
                self.input_stream = open(input_source, "r") (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.edif.tokenizer:[40:49]
==spydrnet.parsers.verilog.tokenizer:[35:44]
            if zipfile.is_zipfile(input_source):
                zip = zipfile.ZipFile(input_source)
                filename = Path(input_source).name
                filename = filename[: filename.rindex(".")]
                stream = zip.open(filename)
                stream = io.TextIOWrapper(stream)
                self.input_stream = stream
            else:
                self.input_stream = open(input_source, "r") (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.library:[208:233]
==spydrnet.ir.netlist:[297:314]
        return c

    def clone(self):
        """Clone the library in an API safe manner.

        The following describes the structure of the returned object:

         * the instances that pointed to reference definitions within the library will have updated
           references
         * the instances that pointed to reference definitions outside the library will maintain
           their definitions
         * the references lists (of definitions) both inside and outsde the library will be updated
           to reflect the change
         * all definitions are cloned within the library.

        """
        memo = {}
        c = self._clone(memo)
        c._clone_rip(memo)
        return c

    def __str__(self):
        """Re-define the print function so it is easier to read"""
        rep = super().__str__()
        rep = rep[:-1] + "; " (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_netlists:[0:9]
==spydrnet.util.get_ports:[0:9]
from spydrnet.ir import (
    Element,
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[110:119]
==spydrnet.util.get_ports:[76:85]
    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if all(isinstance(x, (Element, HRef)) for x in object_collection) is False:
        raise TypeError( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[102:111]
==spydrnet.util.get_pins:[62:71]
    if isinstance(obj, (Element, HRef)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if all(isinstance(x, (Element, HRef)) for x in object_collection) is False:
        raise TypeError( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[119:130]
==spydrnet.util.get_instances:[127:138]
        object_collection,
        patterns,
        key,
        is_case,
        is_re,
        selection,
        recursive,
        filter_func,
    )

 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[91:102]
==spydrnet.util.get_libraries:[98:109]
        )

    filter_func = kwargs.get("filter", lambda x: True)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )
    key = kwargs.get("key", ".NAME")
    recursive = kwargs.get("recursive", False)
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[2:11]
==spydrnet.util.get_wires:[1:10]
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition,
    Instance,
    Port,
    Cable, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_parser:[17:30]
==spydrnet.parsers.verilog.parser:[42:55]
    class BlackboxHolder:
        """this is an internal class that helps manage
        modules that are instanced before they are declared"""

        def __init__(self):
            self.name_lookup = {}
            self.defined = set()

        def get_blackbox(self, name):
            """creates or returns the black box based on the name"""
            if name in self.name_lookup:
                return self.name_lookup[name]
            else: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.port:[124:145]
==spydrnet.ir.wire:[24:34]
    @property
    def pins(self):
        """Get a list of the pins that are in the port"""
        return ListView(self._pins)

    @pins.setter
    def pins(self, value):
        """
        This function can set the pins for the port, but it can only be used to reorder the pins
        in the port. It cannot be used to add or remove pins from the port. to do this use the
        add_pin or remove_pin functions instead

        parameters
        ----------

        value - (List of InnerPin objects) the reordered pins

        """
        value_list = list(value)
        value_set = set(value_list)
        assert ( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.definition:[540:568]
==spydrnet.ir.port:[288:309]
        return c

    def clone(self):
        """Clone the port in an api safe way.

        The following rules will be observed:

         * all the pins will be disconnected from wires
         * the port will be orphaned
         * all pins will belong to the returned port
         * direction, downto, is_scalar, lower_index will all be maintained

        """
        c = self._clone({})
        c._clone_rip()
        return c

    def __str__(self):
        """Re-define the print function so it is easier to read"""
        rep = super().__str__()
        rep = rep[:-1] + "; " (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.cable:[43:55]
==spydrnet.ir.port:[63:74]
        if name is not None:
            self.name = name

        if is_downto is not None:
            self.is_downto = is_downto

        if is_scalar is not None:
            self.is_scalar = is_scalar

        if lower_index is not None:
            self.lower_index = lower_index
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_netlists:[76:84]
==spydrnet.util.get_pins:[63:71]
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if all(isinstance(x, (Element, HRef)) for x in object_collection) is False:
        raise TypeError( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_definitions:[221:229]
==spydrnet.util.get_netlists:[139:147]
            if definition:
                object_collection.append(definition)
        elif isinstance(obj, Wire):
            cable = obj.cable
            if cable:
                object_collection.append(cable)
        elif isinstance(obj, HRef):
            if obj.is_valid: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_definitions:[109:117]
==spydrnet.util.get_ports:[77:85]
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if all(isinstance(x, (Element, HRef)) for x in object_collection) is False:
        raise TypeError( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[1:9]
==spydrnet.util.get_netlists:[1:9]
    Element,
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[100:109]
==spydrnet.util.get_wires:[63:72]
    recursive = kwargs.get("recursive", False)

    if isinstance(obj, (Element, HRef)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[103:111]
==spydrnet.util.get_instances:[111:119]
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj]
    if all(isinstance(x, (Element, HRef)) for x in object_collection) is False:
        raise TypeError( (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_libraries:[230:238]
==spydrnet.util.get_netlists:[126:134]
            definition = obj.definition
            if definition:
                object_collection.append(definition)
        elif isinstance(obj, InnerPin):
            port = obj.port
            if port:
                object_collection.append(port)
        elif isinstance(obj, OuterPin): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_definitions:[8:18]
==spydrnet.util.get_libraries:[9:19]
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef
from spydrnet.util.selection import Selection
from spydrnet.global_state.global_service import lookup
from spydrnet.util.patterns import _is_pattern_absolute, _value_matches_pattern

 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[120:130]
==spydrnet.util.get_libraries:[128:138]
        patterns,
        key,
        is_case,
        is_re,
        selection,
        recursive,
        filter_func,
    )

 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[328:337]
==spydrnet.util.get_hwires:[343:352]
                search_stack += (
                    x for x in _get_hpins_from_hwire(hwire_inside) if x != hpin
                )

        if selection in {Selection.OUTSIDE, Selection.BOTH, Selection.ALL}:
            hwire_outside = _get_outer_hwire_from_hpin(hpin)
            if hwire_outside and hwire_outside not in found_hwires:
                found_hwires.add(hwire_outside)
                yield hwire_outside (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[102:111]
==spydrnet.plugins.namespace_manager.edif_namespace:[144:152]
            if element_type not in self.namespaces:
                self.namespaces[element_type] = {}
            namespace = self.namespaces[element_type]
            if ".NAME" in element:
                old_name = element[".NAME"]
                if old_name in namespace:
                    del namespace[old_name]
            namespace[value] = element (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[37:45]
==spydrnet.plugins.namespace_manager.edif_namespace:[48:56]
        if isinstance(element, Netlist):
            for library in element.libraries:
                if ".NAME" in library:
                    name = library[".NAME"]
                    if name not in namespace:
                        namespace.add(name)
                    else:
                        return False (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_tokenizer:[89:97]
==spydrnet.parsers.edif.tokenizer:[129:137]
    def expect(self, other):
        if not self.token_equals(other):
            raise RuntimeError(
                "Parse error: Expecting {} on line {}, recieved {}".format(
                    other, self.line_number, self.token
                )
            )
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_tokenizer:[80:89]
==spydrnet.parsers.edif.tokenizer:[74:83]
        return self.token

    def peek(self):
        if self.next_token:
            return self.next_token
        else:
            self.next_token = next(self.generator)
            return self.next_token
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_tokenizer:[59:67]
==spydrnet.parsers.verilog.tokenizer:[66:74]
    def has_next(self):
        try:
            self.peek()
            return True
        except StopIteration:
            return False

    def next(self): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_tokenizer:[40:49]
==spydrnet.parsers.verilog.tokenizer:[53:62]
            self.input_stream = open(input_source, "r")
        else:
            if isinstance(input_source, io.TextIOBase) is False:
                self.input_stream = io.TextIOWrapper(input_source)
            else:
                self.input_stream = input_source

        self.generator = self.generate_tokens()
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.edif.tokenizer:[61:69]
==spydrnet.parsers.verilog.tokenizer:[138:146]
    def has_next(self):
        try:
            self.peek()
            return True
        except StopIteration:
            return False

    def next(self): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_parser:[274:282]
==spydrnet.parsers.verilog.parser:[777:785]
                while True:
                    current_level = current_level.parent
                    try:
                        current_level.parent
                    except AttributeError:
                        new_level = current_level
                        break
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.definition:[250:257]
==spydrnet.ir.port:[241:248]
                outer_pin = reference.pins[pin]
                wire = outer_pin.wire
                if wire:
                    wire.disconnect_pin(outer_pin)
                del reference._pins[pin]
                outer_pin._instance = None
                outer_pin._inner_pin = None (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.definition:[149:156]
==spydrnet.ir.port:[35:42]
        self,
        name=None,
        properties=None,
        is_downto=None,
        is_scalar=None,
        lower_index=None,
        direction=None, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.cable:[197:216]
==spydrnet.ir.port:[287:307]
        c._data = deepcopy(self._data)
        return c

    def clone(self):
        """Clone the port in an api safe way.

        The following rules will be observed:

         * all the pins will be disconnected from wires
         * the port will be orphaned
         * all pins will belong to the returned port
         * direction, downto, is_scalar, lower_index will all be maintained

        """
        c = self._clone({})
        c._clone_rip()
        return c

    def __str__(self):
        """Re-define the print function so it is easier to read""" (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.cable:[18:25]
==spydrnet.ir.port:[34:41]
    def __init__(
        self,
        name=None,
        properties=None,
        is_downto=None,
        is_scalar=None,
        lower_index=None, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.instance:[44:52]
==spydrnet.ir.library:[32:41]
        if name is not None:
            self.name = name
        if properties is not None:
            assert isinstance(properties, dict), "properties must be a dictionary"
            for key in properties:
                self[key] = properties[key]

    @property (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_pins:[62:69]
==spydrnet.util.get_wires:[65:72]
    if isinstance(obj, (Element, HRef)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_pins:[90:97]
==spydrnet.util.get_ports:[123:130]
        elif isinstance(obj, Netlist):
            for library in obj.libraries:
                for definition in library.definitions:
                    object_collection.append(definition)
        elif isinstance(obj, Library):
            object_collection += obj.definitions
        elif isinstance(obj, Instance): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[222:229]
==spydrnet.util.get_netlists:[141:148]
        elif isinstance(obj, Wire):
            cable = obj.cable
            if cable:
                object_collection.append(cable)
        elif isinstance(obj, HRef):
            if obj.is_valid:
                item = obj.item (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hwires:[66:75]
==spydrnet.util.get_instances:[85:94]
        for x in kwargs
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[93:100]
==spydrnet.util.get_netlists:[67:75]
    filter_func = kwargs.get("filter", lambda x: True)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )
    key = kwargs.get("key", ".NAME")
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[0:7]
==spydrnet.util.get_definitions:[0:7]
from spydrnet.ir import (
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_definitions:[223:231]
==spydrnet.util.get_libraries:[241:249]
        elif isinstance(obj, Wire):
            cable = obj.cable
            if cable:
                object_collection.append(cable)
        elif isinstance(obj, HRef):
            if obj.is_valid:
                object_collection.append(obj.item)
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hinstances:[146:153]
==spydrnet.util.get_libraries:[229:236]
        elif isinstance(obj, (Port, Cable)):
            definition = obj.definition
            if definition:
                object_collection.append(definition)
        elif isinstance(obj, InnerPin):
            port = obj.port
            if port: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_libraries:[100:107]
==spydrnet.util.get_ports:[68:76]
    filter_func = kwargs.get("filter", lambda x: True)
    is_case = kwargs.get("is_case", True)
    is_re = kwargs.get("is_re", False)
    patterns = (
        args[0] if len(args) == 1 else kwargs.get("patterns", ".*" if is_re else "*")
    )
    key = kwargs.get("key", ".NAME")
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[214:221]
==spydrnet.util.get_libraries:[233:240]
        elif isinstance(obj, InnerPin):
            port = obj.port
            if port:
                object_collection.append(port)
        elif isinstance(obj, OuterPin):
            instance = obj.instance
            if instance: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hports:[74:81]
==spydrnet.util.get_netlists:[75:82]
    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[88:95]
==spydrnet.util.get_ports:[76:83]
    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[148:156]
==spydrnet.util.get_hwires:[148:156]
                else:
                    bypass_namesearch.discard(obj)
                    reference = item.reference
                    if reference:
                        if selection in {Selection.INSIDE, Selection.ALL}:
                            # Get all cables inside a hierarchical instance
                            for cable in reference.cables:
                                hcable = HRef.from_parent_and_item(obj, cable) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[66:75]
==spydrnet.util.get_libraries:[84:93]
        for x in kwargs
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[7:14]
==spydrnet.util.get_libraries:[8:15]
    Definition,
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef
from spydrnet.util.selection import Selection (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[1:8]
==spydrnet.util.get_netlists:[2:9]
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[74:81]
==spydrnet.util.get_instances:[110:117]
    if isinstance(obj, (FirstClassElement, InnerPin, OuterPin, Wire)) is False:
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.edif.tokenizer:[70:77]
==spydrnet.parsers.verilog.tokenizer:[75:82]
            self.token = self.next_token
            self.next_token = None
        else:
            self.token = next(self.generator)
        return self.token

    def peek(self): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.definition:[365:371]
==spydrnet.ir.port:[35:41]
        self,
        name=None,
        properties=None,
        is_downto=None,
        is_scalar=None,
        lower_index=None, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.cable:[198:216]
==spydrnet.ir.definition:[540:566]
        return c

    def clone(self):
        """
        Clone the Cable and all of its wires in an api safe way
        the following will be true of the returned cable

         * The cable will be orphaned from any definitions
         * the wires in the cable will not be connected to any pins
         * is_downto, is_scalar, lower_index will be maintained
         * the wires in the cable will all have the cable set as the parent
        """
        c = self._clone({})
        c._clone_rip()
        return c

    def __str__(self):
        """Re-define the print function so it is easier to read""" (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.cable:[19:25]
==spydrnet.ir.definition:[149:155]
        self,
        name=None,
        properties=None,
        is_downto=None,
        is_scalar=None,
        lower_index=None, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.outerpin:[93:109]
==spydrnet.ir.wire:[170:187]
        return c

    def clone(self):
        """clone wire in an api safe way.

        The following properties can be expected from the returned element:
         * The wire is not connected to any pins.
         * The wire is orphaned from any cable.
         * No pins are connected to the wire
        """
        c = self._clone({})
        c._clone_rip()
        return c

    def index(self):
        """if this wire is in a cable, returns the index number of the wire in the parent cable"""
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.instance:[44:51]
==spydrnet.ir.netlist:[58:65]
        if name is not None:
            self.name = name
        if properties is not None:
            assert isinstance(properties, dict), "properties must be a dictionary"
            for key in properties:
                self[key] = properties[key]
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hinstances:[147:153]
==spydrnet.util.get_netlists:[126:132]
            definition = obj.definition
            if definition:
                object_collection.append(definition)
        elif isinstance(obj, InnerPin):
            port = obj.port
            if port: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_netlists:[3:9]
==spydrnet.util.get_wires:[1:7]
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_pins:[125:131]
==spydrnet.util.get_ports:[143:149]
        elif isinstance(obj, Wire):
            object_collection += obj.pins
        elif isinstance(obj, Cable):
            object_collection += obj.wires
        elif isinstance(obj, HRef):
            if obj.is_valid: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hwires:[89:95]
==spydrnet.util.get_pins:[63:69]
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[199:205]
==spydrnet.util.get_pins:[106:112]
                port = obj.port
                if port:
                    definition = port.definition
                    if definition:
                        for instance in definition.references:
                            outer_pin = instance.pins[obj] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[280:286]
==spydrnet.util.get_definitions:[248:254]
            else:
                names_to_remove = []
                for name in namemap:
                    if _value_matches_pattern(name, pattern, is_case, is_re):
                        result = namemap[name]
                        names_to_remove.append(name) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_definitions:[193:199]
==spydrnet.util.get_libraries:[210:216]
                            if recursive:
                                object_collection.append(parent)
        elif isinstance(obj, Instance):
            if selection == Selection.INSIDE:
                reference = obj.reference
                if reference: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_libraries:[85:93]
==spydrnet.util.get_wires:[49:57]
    ):
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[222:228]
==spydrnet.util.get_libraries:[241:247]
        elif isinstance(obj, Wire):
            cable = obj.cable
            if cable:
                object_collection.append(cable)
        elif isinstance(obj, HRef):
            if obj.is_valid: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_definitions:[109:115]
==spydrnet.util.get_hports:[75:81]
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_definitions:[8:14]
==spydrnet.util.get_hcables:[8:14]
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef
from spydrnet.util.selection import Selection (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_definitions:[1:7]
==spydrnet.util.get_hcables:[2:8]
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[89:95]
==spydrnet.util.get_wires:[66:72]
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hinstances:[115:121]
==spydrnet.util.get_hpins:[115:121]
    while object_collection:
        obj = object_collection.pop()
        if isinstance(obj, Netlist):
            top_instance = obj.top_instance
            if top_instance:
                href = HRef.from_parent_and_item(None, top_instance) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[103:109]
==spydrnet.util.get_hpins:[75:81]
        try:
            object_collection = list(iter(obj))
        except TypeError:
            object_collection = [obj]
    else:
        object_collection = [obj] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[1:7]
==spydrnet.util.get_hpins:[2:8]
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library,
    Definition, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[7:13]
==spydrnet.util.get_libraries:[8:14]
    Definition,
    Instance,
    Port,
    Cable,
)
from spydrnet.util.hierarchical_reference import HRef (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[1:7]
==spydrnet.util.get_libraries:[1:7]
    FirstClassElement,
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[262:268]
==spydrnet.util.get_hports:[247:253]
                    name_stack.pop()
                if recursive:
                    for child in reference.children:
                        if child.reference:
                            href_child = HRef.from_parent_and_item(href_instance, child)
                            search_stack.append((href_child, False)) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[180:186]
==spydrnet.util.get_hports:[173:179]
                    else:
                        port = pin.port
                        if port:
                            href_port = HRef.from_parent_and_item(
                                href_parent_instance, port
                            ) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[142:148]
==spydrnet.util.get_hports:[140:146]
                        if recursive:
                            for child in reference.children:
                                href_child = HRef.from_parent_and_item(obj, child)
                                bypass_namesearch.add(href_child)
                                object_collection.append(href_child)
            elif isinstance(item, Port): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[129:136]
==spydrnet.util.get_hports:[129:136]
                else:
                    bypass_namesearch.discard(obj)
                    reference = item.reference
                    if reference:
                        # Get all cables inside a hierarchical instance
                        for port in reference.ports:
                            hport = HRef.from_parent_and_item(obj, port) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_tokenizer:[35:40]
==spydrnet.parsers.verilog.tokenizer:[40:45]
                stream = io.TextIOWrapper(stream)
                self.input_stream = stream
            else:
                self.input_stream = open(input_source, "r")
        elif isinstance(input_source, Path): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.eblif.eblif_tokenizer:[21:28]
==spydrnet.parsers.verilog.tokenizer:[27:34]
        return tokenizer

    def __init__(self, input_source):
        # self.file = file
        self.token = None
        self.next_token = None
        self.line_number = 0 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.parsers.edif.tokenizer:[0:7]
==spydrnet.parsers.verilog.tokenizer:[3:8]
from functools import partial
import re
import zipfile
import io
from pathlib import Path

 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.cable:[198:214]
==spydrnet.ir.wire:[170:184]
        return c

    def clone(self):
        """clone wire in an api safe way.

        The following properties can be expected from the returned element:
         * The wire is not connected to any pins.
         * The wire is orphaned from any cable.
         * No pins are connected to the wire
        """
        c = self._clone({})
        c._clone_rip()
        return c
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.cable:[55:62]
==spydrnet.ir.port:[77:84]
        if properties is not None:
            assert isinstance(properties, dict), "properties must be a dictionary"
            for key in properties:
                self[key] = properties[key]

    def _items(self):
        """Overrides the bundle _items function to return wires""" (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.innerpin:[51:66]
==spydrnet.ir.outerpin:[93:108]
        return c

    def clone(self):
        """Clone the pin in an api safe way.

        The following conditions will be met with the returned outer pin:

         * the pin will not be connected to any wires
         * the pin will be orphaned from any instance
         * the pin will not be connected to any inner pins
        """
        c = self._clone({})
        c._clone_rip()
        return c
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.ir.innerpin:[35:45]
==spydrnet.ir.outerpin:[76:86]
        self._wire = None

    def _clone(self, memo):
        """Not api safe clone function

        clone leaving all references in tact.
        the element can then either be ripped or ripped and replaced"""
        assert (
            self not in memo
        ), "the object should not have been copied twice in this pass" (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_definitions:[241:246]
==spydrnet.util.get_hinstances:[177:182]
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_ports:[129:134]
==spydrnet.util.get_wires:[112:117]
        elif isinstance(obj, Instance):
            reference = obj.reference
            if reference:
                object_collection.append(reference)
        elif isinstance(obj, Port): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[214:219]
==spydrnet.util.get_netlists:[129:134]
        elif isinstance(obj, InnerPin):
            port = obj.port
            if port:
                object_collection.append(port)
        elif isinstance(obj, OuterPin): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hwires:[186:191]
==spydrnet.util.get_wires:[122:127]
                if selection == Selection.INSIDE:
                    if obj not in in_yield:
                        in_yield.add(obj)
                        yield obj
                elif selection == Selection.OUTSIDE: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hwires:[273:278]
==spydrnet.util.get_ports:[161:166]
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[167:172]
==spydrnet.util.get_wires:[106:111]
                if recursive or selection == Selection.ALL:
                    object_collection += obj.children
            if selection in {Selection.OUTSIDE, Selection.BOTH, Selection.ALL}:
                for port in obj.ports:
                    for pin in port.pins: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_instances:[202:207]
==spydrnet.util.get_libraries:[219:224]
                    if recursive:
                        object_collection += reference.children
            else:
                parent = obj.parent
                if parent: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[1:6]
==spydrnet.util.get_libraries:[2:7]
    InnerPin,
    OuterPin,
    Wire,
    Netlist,
    Library, (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hports:[204:209]
==spydrnet.util.get_instances:[244:249]
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hports:[149:154]
==spydrnet.util.get_hwires:[181:186]
            elif isinstance(item, Cable):
                for wire in item.wires:
                    href_wire = HRef.from_parent_and_item(obj, wire)
                    object_collection.append(href_wire)
            elif isinstance(item, Wire): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[68:75]
==spydrnet.util.get_pins:[46:53]
        raise TypeError("Unknown usage. Please see help for more information.")

    # Default values
    selection = kwargs.get("selection", Selection.INSIDE)
    if isinstance(selection, str):
        if selection in Selection.__members__:
            selection = Selection[selection] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_cables:[272:277]
==spydrnet.util.get_hcables:[267:272]
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hinstances:[122:127]
==spydrnet.util.get_hpins:[122:127]
        elif isinstance(obj, HRef):
            if obj.is_valid is False:
                continue
            item = obj.item
            if isinstance(item, Instance): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[128:134]
==spydrnet.util.get_hwires:[147:152]
                    _update_hwire_namemap(obj, recursive, in_namemap, namemap)
                else:
                    bypass_namesearch.discard(obj)
                    reference = item.reference
                    if reference: (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hpins:[211:216]
==spydrnet.util.get_libraries:[259:264]
        for pattern in patterns:
            pattern_is_absolute = _is_pattern_absolute(pattern, is_case, is_re)
            if pattern_is_absolute:
                if pattern in namemap:
                    result = namemap[pattern] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.util.get_hcables:[179:184]
==spydrnet.util.get_hpins:[153:158]
            elif isinstance(item, Cable):
                for wire in item.wires:
                    href_wire = HRef.from_parent_and_item(obj, wire)
                    object_collection.append(href_wire)
            elif isinstance(item, Wire): (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[121:126]
==spydrnet.plugins.namespace_manager.edif_namespace:[179:184]
    def lookup(self, element_type, key, value):
        if key == ".NAME":
            if element_type in self.namespaces:
                namespace = self.namespaces[element_type]
                return namespace.get(value, None) (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[114:121]
==spydrnet.plugins.namespace_manager.edif_namespace:[165:171]
            if element_type in self.namespaces:
                namespace = self.namespaces[element_type]
                if ".NAME" in element:
                    old_name = element[".NAME"]
                    if old_name in namespace:
                        del namespace[old_name]
 (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[104:109]
==spydrnet.plugins.namespace_manager.edif_namespace:[166:171]
            namespace = self.namespaces[element_type]
            if ".NAME" in element:
                old_name = element[".NAME"]
                if old_name in namespace:
                    del namespace[old_name] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[115:121]
==spydrnet.plugins.namespace_manager.edif_namespace:[146:151]
            namespace = self.namespaces[element_type]
            if ".NAME" in element:
                old_name = element[".NAME"]
                if old_name in namespace:
                    del namespace[old_name] (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0801: Similar lines in 2 files
==spydrnet.plugins.namespace_manager.default_namespace:[92:97]
==spydrnet.plugins.namespace_manager.edif_namespace:[127:132]
        if element_type in self.namespaces:
            namespace = self.namespaces[element_type]
            if value in namespace:
                if namespace[value] != element:
                    return False (duplicate-code)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet.shortcuts.getter -> spydrnet.util.get_hports -> spydrnet.util.hierarchical_reference) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_instances -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_hports) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet.shortcuts.getter -> spydrnet.util.get_instances -> spydrnet.util.hierarchical_reference) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_instances -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_pins -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.parsers -> spydrnet.parsers.primitive_library_reader -> spydrnet.parsers.verilog.parser -> spydrnet.plugins.namespace_manager -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.parsers -> spydrnet.parsers.primitive_library_reader -> spydrnet.parsers.verilog.parser -> spydrnet.plugins.namespace_manager -> spydrnet.plugins.namespace_manager.default_namespace -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.parsers -> spydrnet.parsers.primitive_library_reader -> spydrnet.parsers.verilog.parser -> spydrnet.plugins.namespace_manager -> spydrnet.plugins.namespace_manager.edif_namespace -> spydrnet.plugins.namespace_manager.default_namespace -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_instances) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_hpins -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_hports) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_hports) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_hcables -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_hports) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet.shortcuts.getter -> spydrnet.util.get_pins -> spydrnet.util.hierarchical_reference) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_instances -> spydrnet.global_state.global_service -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_pins -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_instances -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_libraries -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_instances -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_cables -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_hwires -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_hports) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.parsers -> spydrnet.parsers.primitive_library_reader -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_instances -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_cables -> spydrnet.global_state.global_service -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_instances -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_ports -> spydrnet.global_state.global_service -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_wires -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_hports) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_hinstances -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_hports) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_instances -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_definitions -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_netlists -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_hports) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_pins -> spydrnet.util.hierarchical_reference -> spydrnet.shortcuts.getter -> spydrnet.util.get_hports) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_instances -> spydrnet.util.hierarchical_reference -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.util.get_hports -> spydrnet.util.hierarchical_reference -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.composers -> spydrnet.composers.verilog.composer -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.composers -> spydrnet.composers.edif.composer -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.composers -> spydrnet.composers.eblif.eblif_composer) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.parsers -> spydrnet.parsers.primitive_library_reader -> spydrnet.parsers.verilog.verilog_tokens) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.parsers -> spydrnet.parsers.edif.parser -> spydrnet.plugins.namespace_manager -> spydrnet.ir) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.parsers -> spydrnet.parsers.primitive_library_reader -> spydrnet.parsers.verilog.parser -> spydrnet.parsers.verilog.tokenizer -> spydrnet.parsers.verilog.verilog_token_factory -> spydrnet.parsers.verilog.verilog_tokens) (cyclic-import)
spydrnet/parsers/eblif/__init__.py:1:0: R0401: Cyclic import (spydrnet -> spydrnet.parsers -> spydrnet.parsers.eblif.eblif_parser -> spydrnet.ir) (cyclic-import)

------------------------------------------------------------------
Your code has been rated at 8.33/10 (previous run: 8.31/10, +0.01)

